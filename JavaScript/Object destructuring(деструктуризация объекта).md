Помимо массивов деструктурировать мы также можем и объекты. 

Точно также, как в случае с деструктуризацией массива, мы сначала ставим скобочки, соответствующие той боевой единице, из которой мы собираемся деструктуризацией что-то изымать.
```js
// Destructuring
const developer = {
 id: 1,
 fullName: 'John Doe',
 skills: ['HTML', 'CSS', 'JavaScript'],
 area: 'frontend',
 languages: {
  english: 'B2',
  spanish: 'native',
  hebrew: 'A1',
 },
};

const {} = developer;
```

В случае с массивом мы работали по порядку. Мы писали любое имя переменной, абсолютно любое, оно могло называться как угодно, а потом просто по порядку извлекали элементы.

В случае с объектом немножко по-другому. Порядок нас вообще не волнует, потому что объект, это неупорядоченная история.

Здесь у нас никакой гарантии, в каком порядке эти элементы будут расположены, нету. Но у нас здесь есть название этих ключей. 

Мы можем захотеть создать переменную, в которой будет лежать слово `frontend`. Но мы гарантированно должны создать эту переменную со словом area, и вне зависимости от того,
первым я здесь ее напишу, вторым, десятым и так далее, я положу сюда значение `frontend`.
```js
const { area, id } = developer;
console.log(area, id); // frontend 1
```
 То есть порядок нас не волнует, нас волнует название ключей. По названиям ключей мы уже
извлекаем значения. Какое имя ключа в объекте, по такому имени мы создаем переменную.

Но, разумеется, у нас эта переменная уже может существовать в приложении. 

Как мне создать переменную, допустим, developer area. Мне в любом случае нужно обратиться к этому ключу. Поэтому я в любом случае пишу area, но дальше я просто беру и использую
синтаксис переименования. Я ставлю двоеточие и пишу любое имя, какое хочу.
```js
const area = 'abc';

const {
 area: areaDeveloper,
 id
} = developer;

console.log(area, areaDeveloper, id);// abc frontend 1
```
Что происходит? Я говорю, что для деструктуризации возьми объект, в этом объекте найди ключ area, возьми это значение и положи в мою новую переменную, которую я назвал `areaDeveloper`.

Также, как и в случае с массивами, мы можем использовать значение по умолчанию. Даже после переименования, если оно у нас есть, мы можем значение по умолчанию здесь присваивать, никаких проблем нету. 
```js
const {
 area: areaDeveloper = '',
 id = null,
 ...otherProp
} = developer;
```
Также, как и в случае с массивами, нам доступен оператор остатка, опять же может быть tail,
как хвост, остаток от чего-то, либо мы можем назвать `otherProp`,  оставшиеся свойства
от этого developer. Опять же, так как он остаток,
он всегда идет последним, после него не ставится запятая. 

Но мы опять же можем проверить, если это объект, а в данном случае это объект, то этот остаток тоже будет объектом. Cо всеми ключами, которые мы не изъяли. 

Очень удобно, очень помогает решать самые разные задачи.

Допустим, у меня есть вложенный объект в объекте, и я хочу получить значение `B2`. Как мне быть? Я должен пойти по порядочку. Я должен сказать, что вот у меня ключ `languages`, сделай вот таким вот образом деструктуризацию.
```js
const {
 area: areaDeveloper = '',
 id = null,
 languages: {
  english
 },
 ...otherProp
} = developer;
console.log(english); // B2
```
Опять же любое количество значений, переименование здесь запросто тоже можем использовать, Значение по умолчанию
можем использовать, никаких ограничений нету.

Если у нас вложенный массив, то как нам быть со вложенным массивом? 
```js
const {
 area: areaDeveloper = '',
 id = null,
 languages: {
  english
 },
 skills: [,,basicSkill],
 ...otherProp
} = developer;
console.log(basicSkill); // JavaScript
```
По сути, точно также, мы говорим, что вот у меня есть скиллы, а из скиллов я хочу сделать
деструктуризацию по порядочку. Взять первый скилл, допустим, basic. `BasicSkill`, я ожидаю, что это самый первый, что это HTML. Если мне нужен второй, я должен буду сначала запятую поставить, если нужен третий, две запятые.

Давайте третий, мы ожидаем JavaScript получить, наш `basicSkill`.

Точно также здесь работает история со значениями по умолчанию. Мы должны гарантировать, что `dereloper`, это у нас объект. Он нам может прийти пустым, с сервера может прийти null. 
```js
const {
 area: areaDeveloper = '',
 id = null,
 languages: {
  english
 } = {},
 skills: [,,basicSkill] = [],
 ...otherProp
} = developer || {};
```

Если я захочу сделать деструктуризацию без объявления директивы, вот так, то есть объявление директивы, всё понятно. 
```js
let area, id;
{area, id} = developer;
```
Даже если я включу такой синтаксис,
у меня сразу будет ошибка. Почему? Потому что для JavaScript фигурные скобки – это блок кода.

```js
({area, id} = developer);
```
Поэтому, чтобы JavaScript однозначно
понимал, с чем мы работаем, мы должны всю эту конструкцию обернуть внезапно в круглые скобки. 

Тогда он уже не будет воспринимать это как блок кода, он будет воспринимать это как деструктуризацию.