Одним из самых частых кейсов, когда мы работаем с массивами, это обход массива, перебор
всех его значений и что-то с этими значениями
нужно сделать. 

Здесь нам на помощь существует две метода. Один называется `map`, другой называется `forEach`.

Мы с вами рассматривали функции высшего порядка и колбэки. По сути, вот эти методы, это как функции высшего порядка, которые выполняются для конкретного массива, то есть они работают в пределах массива. Они выполняют определенные операции.
```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8];

numbers.forEach(fn);
```
В данном случае так функция, которую мы должны сюда передать, поочередно будет выполняться
для каждого элемента массива. 
Поэтому в данном случае очень легко работать с методом `forEach`, обычно его легче всего запомнить, просто потому что в названии сказано "для каждого", "для каждого сделай что-то", и эта функция будет, соответственно, что-то делать для каждого.

Функция может быть написана прямо здесь, либо она может быть написана во вне. 
Давайте посмотрим вариант, когда функция предварительно создается.
```js
function print(el) {
 console.log(el);
}
numbers.forEach(print);
```
Соответственно, мы скажем, допустим, просто "напечатай".  Мы будем сюда принимать
какой-то элемент  и будем этот элемент выводить в console. 

Мы видим, что `forEach` может принимать три значения.
```js
arr.forEach(function callback(currentValue, index, array) {
    //your iterator
}[, thisArg]);
```

`callback`
Функция, которая будет вызвана для каждого элемента массива. Она принимает от одного до трёх аргументов:

`currentValue`
Текущий обрабатываемый элемент в массиве.

`index` Необязательный
Индекс текущего обрабатываемого элемента в массиве.

`array` Необязательный
Массив, по которому осуществляется проход.

`thisArg`
Необязательный параметр. Значение, используемое в качестве `this` при вызове функции `callback`.

More reading in [Link](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)

В данном случае `forEach` может как раз обойти какую-то структуру и что важно, этот метод,
как и другой метод `map`, который мы далее посмотрим, они иммутабельны, то бишь они не изменяют оригинального массива.

Но по факту гораздо более употребимым является второй метод, метод `map`. 
Для маппинга `cosole.log` вообще никак не подходит, потому что когда мы работаем с маппом, мы предполагаем, что нам будет возвращаться новый массив.
```js
// map 
const numbers = [1, 2, 3, 4, 5, 6, 7, 80];

function doubleNum(num) {
 return num * 2;
}

const result = numbers.map(doubleNum); // [2, 4,6, 8, 10, 12, 14, 16]
```
Таким образом мы будем формировать новый массив, оригинальный при этом у нас
никак не сломается. 

Соответственно, у нас количество
элементов при этом не меняется, как было 8 элементов в массиве, так 8 и есть, но они все новые, все измененные, оригинальный массив
остался не тронутым. 

More reading in [Link](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

