Работая с массивами, нам часто приходится их фильтровать. 
Фильтрация также должна быть иммутабельна,
мы не должны ломать оригинальный массив.

Мы должны создавать новую структуру данных, соответственно, сохраняя туда отфильтрованные значения. Здесь тоже уместно сказать, что у нас есть разница между массивами, в которых лежат
примитивные данные, такие как строки, числа, undefined, булевые значения и так далее,
известные нам примитивы, либо, если это массивы,
в которых лежат объекты. 
```js
const users = [
 {
  id: 1,
  name: 'Brad Pette',
  isMarried: true,
 },
 {
  id:2,
  name: 'Diana Moore',
  isMarried: false,
 },
 {
  id: 3,
  name: 'Olivie Giroud',
  isMarried: true,
 },
 {
  id: 4,
  name: 'Scott Parker',
  isMarried: false,
 },
];
```
Соответственно, такие штуки называют коллекциями. 
Коллекция – это тот же самый массив, который только содержит не примитивы, а объекты.

-------------------
Для фильтрации у нас существует метод, который так и называется `filter` и точно также, как `map`, как `forEach`, этот метод принимает колбэк, он принимает функцию. 
```js
// Filter
const numbers = [1, 2, 3, 4, 5, 6, 7, 8];

const oddNumbers = numbers.filter(num => num % 2 !== 0); // [1, 3, 5, 7]
```
Если в случае с маппингом, мы просто возвращали новое, преобразованное значение, то в случае с фильтром мы должны вернуть true или false. 

В данном случае я хочу использовать какую-то логику по получению нечетных чисел, а то число, которое мне будет передано в качестве параметра, буду по модулю делить его на два и проверять, что  что остаток не равен 0.

В данном случае опять же фильтр как и `map` всегда возвращает нам новый массив. Даже если он не найдет одного значения, которое будет соответствовать этому логическому выражению. Он просто вернет нам пустой массив.

Аналогичным образом мы могли захотеть четные числа, соответственно, `evenNumbers`, и здесь тогда мы должны были бы сказать, что они наоборот равны 0.
```js
const evenNumbers = numbers.filter(num => num % 2 === 0); // [2, 4, 6, 8]
```
Меняется логика, соответственно, меняется содержимое того, что мы получаем по итогу фильтрации.

------
Допустим, мы хотим сделать новую структуру данных, новую коллекцию, которая у меня будет
называться `marriedUsers`, женатые юзеры, я буду обращаться к оригинальной коллекции, говорить: вот тебе метод Фильтр, и точно также я буду получать конкретного юзера в качестве параметра, и я буду делать определенную просто у него проверку.
```js
const marriedUsers = users.filter(user => user.isMarried);
```
Соответственно, если мы получим истину, вся коллекция целиком попадет в новую коллекцию. Если мы получим false, весь объект не попадет в нашу новую коллекцию.
```js
const marriedUsers = [
 {
  id: 1,
  name: 'Brad Pette',
  isMarried: true,
 },
 {
  id: 3,
  name: 'Olivie Giroud',
  isMarried: true,
 },
];
```

Соответственно, если бы нам над было обратную историю сделать, мы бы хотели наоборот
не женатых получить, мы могли бы здесь просто
использовать здесь инверсию.
```js
const marriedUsers = users.filter(user => !user.isMarried);
```

Использовать здесь мы можем самые разные штуки. Допустим, если я бы хотел делать там проверку на какие-то строки, то я мог использовать, допустим, метод `includes`.
```js
const users = [
 {
  id: 1,
  name: 'Brad Pette',
  movies: ['Snatch', 'Inglorious Basterdes'],
  isMarried: true,
 },
 {
  id:2,
  name: 'Diana Moore',
  movies: ['Inglorious Basterdes'],
  isMarried: false,
 },
 {
  id: 3,
  name: 'Olivie Giroud',
  movies: ['Inglorious Basterdes'],
  isMarried: true,
 },
 {
  id: 4,
  name: 'Scott Parker',
  movies: ['Inglorious Basterdes'],
  isMarried: false,
 },
];

const snatchUsers = users.filter(user => user.includes('Snatch'));

console.log(snatchUsers);
//[
// {
//  id: 1,
//  name: 'Brad Pette',
//  movies: ['Snatch', 'Inglorious Basterdes'],
//  isMarried: true,
// },
//]
```
Includes, который у нас работает одинаково как со строками, так и с массивами. Он у нас булевый, он возвращает `true` или `false`.

