Когда мы взаимодействуем с сайтом, наше взаимодействие между клиентом, то бишь нашим браузером и сервером, это место, где происходит логика, которая возвращает нам страницу и не только страницу, а какие-то части страницы, контент, те же картинки,
видео и так далее. 

Так вот, сообщение между клиентом и сервером, браузером и сервером у нас может происходить несколькими путями.

Классический вариант, с чего всё начиналось, это так называемая синхронная работа. Обратите внимание на то, что мы работаем с сайтами. У нас в верхнем углу каждой вкладки есть иконка, и когда мы переходим по сайту, то мы можем обратить внимание, что эта иконка у нас обновляется.

Когда я авторизуюсь, вхожу на сайт, у меня снова происходит перезагрузка полная страницы, и какие-то данные меняются.

То есть мое взаимодействие с сервером синхронное: я что-то выполняю, мое действие
делает запрос на сервер, сервер отправляет мне ответ, у меня полностью перезагружается страница с теми данными, которые прислал мне сервер. 

За всеми этими манипуляциями всегда можно наблюдать на вкладке `Network`.

Есть другой сценарий. Когда мы работаем с сайтом, вот, первый раз у меня что-то загрузилось. Но если я начинаю ходить
по другим страничкам, могу обратить внимание – моя вкладка браузера, она не обновляется.

То есть я просто переключаюсь, у меня меняется содержимое,но при этом страничка полностью не перезагружается. Мы видим это и по иконке, и по тем данным. Это уже взаимодействие, так называемое асинхронное.

Есть еще такой подход, который называется `WebSocket`. Он довольно специфичный и нужен очень редко на специфических проектах. Например, если мы делаем что-то вроде чата.

Разница здесь будет какая? Что, если мы работаем с вами с синхронным или асинхронным вариантом, неважно, мы работаем с протоколом `http`.

Так вот, `http` – это один вариант протокола, он может работать как синхронно, так и асинхронно с нами. `WebSocket`, по сути, это другой протокол.

В чем будет разница? `Http` устанавливает связь
между клиентом и сервером на момент обмена данными. То есть, грубо говоря, мне нужна картинка. Я устанавливаю связь между
клиентом и сервером и посылаю запрос, получаю ответ, соответственно, с самой картинкой.

`WebSocket` работает немножко по-другому, устанавливает постоянное соединение
между клиентом и сервером, и это позволяет не тратить время на дополнительное подключение. То есть подключение постоянное,
и данные могут туда-сюда перебрасываться.

Опять же для активных переписок в чатах, для игр и так далее, это наиболее близкий подход.

В классических сайтах в `WebSocket`, как правило, не нужны.

Но, чтобы еще чуть лучше посмотреть
на протокол `HTTP`, мы с вами обратим внимание
еще на несколько нюансов. Мы подключали большое количество скриптов  в самом конце.  Иногда можно на сайтах встретить, что скрипты, подключенные не в конце, а где-нибудь в начале до тега head. 

В чем здесь может быть подвох и как этого подвоха избежать?

У нас тег script, он может быть в том виде, в каком мы его используем сейчас. Кроме того он может дополнительно содержать атрибуты. Один атрибут называется `async`, другой называется `defer`.  

Делают они примерно одно и то же,
вместе они никогда не используются,то есть либо/либо.

При обычной работе со скриптом, пока у нас идет загрузка сначала каждого скрипта, потом выполнение этого скрипта, то есть строчка за строчкой весь JavaScript должен выполниться. В этот момент у пользователя ничего не будет отрисовываться, и взаимодействие его со страничкой будет приостановлено. 

Только после выполнения всей этой логики у нас будет дальше обрабатываться HTML, если он, конечно, есть. 

Именно поэтому в классическом варианте предлагается скрипт класть в самый конец, перед закрывающимся body, как раз чтобы сначала у нас весь HTML отрисовался, а потом уже начал отрабатывать script, сначала скачивался, а потом выполнялся.

Но иногда хочется немножко другого поведения, особенно если мы ставим
какой-нибудь счетчик на сайт, там Яндекс-метрику или Google-аналитику, то мы можем захотеть, чтобы она выполнилась как можно быстрее, как можно быстрее начался сбор
статистики о посещении сайта.

Здесь есть подход, который, как правило, используется. Добавить атрибут `async`. 

Что он делает и в чем разница с обычным?

Он у нас точно также выполняет отрисовку страницы, потому что script `async`
всегда лежит в head, вниз его класть особо смысла нету. В браузере асинхронно будет
происходить скачивание. Hекое `WebAPI` асинхронно отработает. Параллельно с ним в потоке будет выполняться какая-то работа.

Но когда script полностью скачается, он остановит отрисовку дома, выполнит какую-то свою работу. 

Но в случае с метрикой, с аналитикой
она небольшая, и потом продолжится спокойно
отрисовка страницы дальше.

Последний вариант, так называемый `defer`.
То же самое, что `async` с большим-большим, но очень важным отличием. Опять же script `defer`,  также, как и `async` имеет смысл вешать
только в начало страницы, когда у нас перед head в подвал складывать особого значения не имеет.

Вот, мы дошли по коду до скрипта, у которого есть атрибут `defer`.  Он начал скачивать этот код асинхронно и дальше, выполняя строчку
за строчкой, что написано. Так только он скачал, он ничего не делает. Он ожидает, пока полностью у нас отрисуется весь HTML.

То есть у пользователя страница полностью отрисуется и только потом начнет выполнять
это JavaScript-код. 

Вот это может быть полезен для различных автоматизированных систем, типа `CMS, WordPress, 1С и так далее`, где скрипты добавляются автоматически в шапку или в подвал. 


