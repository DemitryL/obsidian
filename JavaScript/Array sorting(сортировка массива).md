Если мы хотим отсортировать что-либо, будь то коллекция либо просто массив, мы используем встроенный метод, который называется `sort`, но по умолчанию сортирует он не очень красивым.

Если быть правильным, совсем некорректно сортирует.
```js
const numbers = [1, 2, 3, 4, 10, 12, 23];
numbers.sort();
console.log(numbers);// [1, 10, 12, 2, 23, 3, 4]
```
Поэтому нам нужно понять, как с этим работать.
Функция-сортировка, она принимает некую функцию, благодаря которой она понимает,
как сравнивать две единицы и нужно их как-то между собой сортировать или нет, то есть по факту сортировка сравнивает все элементы между собой и определяет, нужно их менять местами или нет,
или это не требуется.

У нас при сравнении двух элементов нужно сказать, какой из них является больше.

И в случае чисел мы можем сделать следующую вещь:
```js
numbers.sort((a,b) => a - b);
```
Вот это выражение нам будет возвращать
либо положительное значение, либо отрицательное значение, либо ноль. 

В случае положительного или отрицательного значения, будет принято решение о том,
что из них больше. Тогда, соответственно, если нужно менять их местами, они меняются. Ежели они равны, менять их точно не нужно.

Если нам нужна сортировка в обратном направлении, мы можем изменить нашу формулу, сказать, у нас, что теперь у нас будет b - a:
```js
numbers.sort((a,b) => b - a);
```
При этом у нас мутировал оригинальный массив, потому что мы выводим в console не результат выполнения этой истории, а именно сам массив, и он изменился.

При этом мы можем сделать еще такую штуку, у нас есть встроенный метод, который называется `reverse`. 
```js
numbers.reverse();
console.log(numbers);
```
Reverse, он ничего не принимает, но что он делает?
Он берет и меняет порядок. То есть опять же мутирует наш изначальный объект.

------
Следующий пример уже будет более веселый.
Эта сортировка, когда мы работаем со строками.

Здесь, наверное, лучше написать функцию отдельно. Функция точно также будет у нас
принимать два элемента, также "a" и "b", а дальше она будет уже по неким условиям нечто делать.
```js
const cities = ['Madrid', 'Amsterdam', 'Paris', 'Berlin', 'Kiev'];

function sorting(a,b) {
 if(a > b) {
  return 1;
 }
 if(a < b) {
  return -1;
 }
 return 0;
};

cities.sort(sorting);
console.log(cities);//['Amsterdam','Berlin','Kiev', 'Madrid', 'Paris']
```
По сути, это очень похоже на наш первый сценарий, где мы получали за счет естественного вычитания чисел либо положительно число, либо отрицательное, либо ноль. 

Здесь всё то же самое, мы должны вернуть либо положительное число, либо отрицательное, либо ноль, если разницы нет. 

В данном случае будут побуквенно идти сравнения, и будут сравниваться кода букв.

-----
Ежели мы работаем с коллекцией, то мы тоже можем захотеть ее отсортировать.

Если мы работаем с коллекцией, это не значит, что мы не можем эту коллекцию передать
в эту же функцию, просто здесь подход немножко изменится. 
```js
// Sort
const developers = [
 {
  id: 1,
  fullName: 'John Doe',
  skills: ['HTML', 'CSS', 'JavaScript'],
  area: 'frontend',
 },
 {
  id: 2,
  fullName: 'Adam Smith',
  skills: ['HTML', 'CSS', 'JavaScript', 'React'],
  area: 'frontend',
 },
 {
  id: 3,
  fullName: 'Will Dowson',
  skills: ['HTML', 'PHP', 'Laravel'],
  area: 'backend',
 },
 {
  id: 4,
  fullName: 'Sam Wilson',
  skills: ['HTML', 'CSS', 'JavaScript', 'PHP'],
  area: 'fullstack',
 },
];

developers.sort((a,b) => sorting(a.area, b.area));
```
Попробуем, developer.sort, и если я просто передам ему эту функцию, этого будет недостаточно. Потому что он будет пытаться
сравнивать два объекта и у него ничего не получится, он не поймет, что делать.

Мы можем сказать: возьми те же самые "a" и "b", а потом вызови функцию сортировки, передав туда эти самые "a" и "b", но передав туда вполне
конкретные ключи. 

Мы могли бы сделать всё и в обратную сторону:
```js
function sorting(a,b) {
 if(a > b) {
  return -1;
 }
 if(a < b) {
  return 1;
 }
 return 0;
};
```
Соответственно, мы взяли и перевернули
всю нашу историю либо могли опять же использовать метод `reverse`. В данном случае он бы тоже у нас отработал.