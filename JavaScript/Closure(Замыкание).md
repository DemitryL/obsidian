Она не так часто используется, но про нее очень часто спрашивают на собеседованиях.

В целом понимание этой штуки упростит понимание в дальнейшем каких-то более сложных подходов, которые используют в частности какие-то библиотеки, которыми в дальнейшем предстоит так или иначе пользоваться. Эта штука называется замыкание.

Точнее, когда мы говорим о замыкании,
мы должны помнить две вещи, что речь будет идти о функциях, которые возвращают другие функции, это первый нюанс.

Второй нюанс это то, что функция,
возвращаемая функция, запоминает то самое слово scope. Соответственно, возвращаемая функция запоминает область видимости, все переменные, которые вокруг себя она видит.
```js
function hello(name) {
 const helloName = () => console.log('hello', name);
 
 return helloName;
}
const helloWorld = hello('world');
helloWorld();
```
Встает вопрос, откуда берется вот этот name? Здесь как раз происходит та самая магия замыкания.

Во-первых, функция у нас является тоже объектом. это значит, что функция у нас может хранить еще какие-то значения, как и любой другой объект: пара, ключ и значение.

Соответственно, помимо той функции,
которую мы вернули отсюда, создали и вернули, мы плюс к этой функции на самом деле еще вернули скрытое поле, которое называется scope, скрытые поля.

Если смотреть, что есть в прототипе того или иного метода, того или иного класса, можно так или иначе столкнуться с различными скрытыми полями. 

Вот в это самое скрытое поле передаются самые разные сущности. 

В данном случае оно тоже может представляться как объект, что там будет храниться?  А там как раз будет храниться всё то, с чем может иметь наша функция,
возвращенная во внешний мир, всё то, что она могла запомнить в нашем случае, она запоминает вполне конкретный name, с вполне конкретным значением. 

То есть вроде бы в локальной памяти нету, в глобальной памяти, даже прежде, чем искать во внешнем мире, еще где-то, даже если мы
где-то создадим name, если он у нас, в принципе, будет, всё равно сначала до того, о поиска в глобальной памяти, JavaScript будет пытаться найти значение в этом самом скрытом поле scope. 

Если он там найдет, он конечно же его использует. Если не может найти,
он не будет его использовать. 

Еще один пример на закрепление мы с вами рассмотрим.
```js
function outer() {
 let counter = 0;

 function incrementCounter() {
  console.log(++counter);
 }

 return incrementCounter;
}

const myCounter1 = outer();
myCounter1(); // 1
myCounter1(); // 2
myCounter1(); // 3
```
Соответственно, мы создадим функцию,
она будет называться `incrementCounter`. Ничего не будет принимать, хотя эти функции, которые мы возвращаем, тоже могут принимать что-нибудь, могут принимать параметры, тогда этот параметр мы можем передать в момент вызова уже второй созданной функции.

При вызове `myCounter1` первый раз,  а в scope найдется значение counter со значением 0, оно увеличится. Во втором вызове снова найдется уже значение 1, увеличится и так далее.

В чем здесь прелесть? В том, что я могу создать вполне независимый `myCounter2`, который будет делать ровно то же самое, но будет иметь абсолютно свои иные, независимые от, соответственно,
первого случая, наборы значений Counter.
```js
const myCounter2 = outer();
myCounter2(); // 1
myCounter2(); // 2
```

Когда мы говорим про замыкание, это значит, что мы имеем в виду, что какая-то функция возвращает нам другую функцию. То есть внутри функции создается функция, и возвращается во внешний мир без вызова. 

Та функция, которая создана и возвращена, она запоминает окружение, запоминает область видимости, запоминает все значения переменных, с которыми она может иметь дело.


