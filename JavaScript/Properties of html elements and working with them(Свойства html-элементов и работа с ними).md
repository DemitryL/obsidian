Начнем вообще с достаточно любопытной вещи, которая говорит о том, что если мы какой-то элемент на странице выберем через код, то у этого кода здесьбудет подсветка ==$0.

Этот $0 на самом деле в режиме console браузера дает нам сам объект.

$0 в нашем JavaScript вообще ничего значить на будет, поэтому в JavaScript-коде мы так не пишем,но для проверки каких-то гипотез прямо в браузере мы можем это использовать.

```html
<a>Text Link</a>
```
Mоя ссылка, я смогу с ней хоть что-то делать. Я могу обратиться к ней и проверить, что у нее лежит внутри. У меня есть свойство `innerText`, которое позволяет мне прочитать содержимое текста, который там есть внутри.
```js
const anchor = document.querySelector('a');
console.log(anchor.innerText); // Text Link
```

Причем не только прочитать, я могу сказать, что пускай текст будет другим.
```js
anchor.innerText = "REST API";
console.log(anchor.innerText); // REST API
```

Есть просто работа с текстом, есть иногда более интересная история, нам нужно иногда работать
не только с тексом, но иногда и с элементами
нужно работать, допустим, параграф.
```js
const p = document.querySelector('p');

p.innerText
// А еще у него есть, помимо innerText, innerHTML.
p.innerHTML
```
`innerHTML` от `innerText` будет отличаться тем, что он содержит все HTML-теги, которые там были.

`InnerHTML` тоже доступен нам для записи, в `innerText` наш HTML не пройдет, если мы захотим туда положить, а вот в `innerHTML` мы можем
любой HTML точно также записать.

Кроме влияния на содержимое, мы можем работать с любыми атрибутами. 

Вот моя обычная ссылка, и я знаю, что у нее есть атрибуты `href`, но и мне по программе может захотеться либо прочитать значение этого `href`,
либо просто проверить, что этот атрибут есть,
я могу использовать метод, который называется `getAttribute()`, дай мне атрибут.
```html
<a href="/ru/docs/Glossary/API" class="link">API</a>
```
Я передаю ему какой-то атрибут.
```js
const a = document.querySelector('a');
a.getAttribute('href'); // "/ru/docs/Glossary/API"
```
В частности я могу передать ему атрибут и `href` и получу его значение. 

Либо я передам атрибут `target`, который у меня здесь на установлен.
```js
a.getAttribute('target');
```
Я узнаю, что его нету, просто получив `null`. Опять же смогу это дело проверить и если я получу, что его нету, смогу установить либо смогу получить значение, сравнить его с каким-то и перезаписать.

Но get, как понятно из названия, он получает данные. Мы, если хотим устанавливать их, мы используем `setAttribute`. Вместо `get` просто пишем `set`.
```js
a.setAttribute('target', '_blank');
```
`Set` имеет уже два параметра. Первый, точно также мы имеем возможность написать имя, какого-то атрибута HTML. Второй, это то значение, которое мы хотим ему назначить.

Такой подход работает с абсолютно любыми атрибутами. Но иногда бывает проще
работать немножко по-другому.

Допустим, если я хочу работать с `href`, я могу написать название моего объекта, а любой элемент,
как мы уже знаем, это объект, и написать просто `a.href`, и получить всё то же самое, получить ту же самую ссылку.
```js
console.log(a.href); // "https://developer.mozilla.org/ru/docs/Glossary/API" 
```
Но в данном случае мы видим, что выглядит она немножко по-другому. 

Точно также я могу ее здесь переписать. Я могу сказать, что мой `href` будет равен теперь другой ссылке.
```js
a.href = '/404';
```

Возможность у нас есть, естественно, для любого атрибута, но с той поправкой, что у нас
есть атрибут `className`, если мы говорим про JavaScript.
```js
console.log(a.className); // link 
```
Но в JavaScript у нас `class` слово зарезервированное. Поэтому в JavaScript мы не можем писать просто `class`, мы должны написать `className`, мы получим то значение, которое у нас есть в реальном доме.

Если атрибут какой-то сложный, состоит из нескольких слов, разделяемых тире, то мы используем `CamelCase`.

Кроме `className` у нас есть еще один атрибут.
Он применим к такому HTML-тегу как `label`. 

У HTML `label` есть атрибут `for`, а for, как мы знаем, в JavaScript тоже зарезервированное слово.  
Поэтому, если вдруг вам нужно будет
обращаться к атрибуту `for`, он будет называться,
как ни странно, `htmlFor`.
```js
label.htmlFor
```
Уточняем, что это не JavaScript for, а тот, который есть в html, конкретный атрибут, опять же на чтении
и на записи он будет работать.

Более интересная возможность, это возможность манипулировать цветами.
```js
a.style
```
Мы знаем, что style – это валидный атрибут для html с точки зрения JavaScript, это некий объект, это специальный объект, который
называется `CSSStyleLeDeclaration`.

```js
//Я могу сказать, что пускай цвет моей ссылки сейчас будет внезапно оранжевым, и ссылка окрасилась в оранжевый цвет.
a.style.color = 'orange';

//Или я могу сказать: пускай сейчас моя ссылка станет невидимой, скажу, что dispay none.
a.style.display = 'none';
```

Последнее, о чем хочется сказать, это то, что в JavaScript вы можете встретить то, что на любом обычном HTML-элементе могут висеть атрибуты
с префиксом data, data.что-то: `data.id, data.name, data.color` и так далее. 

Этих data-атрибутов на одном и том же элементе может быть любое количество. 

Как получается к ним доступ? Во-первых, мы можем получать к ним доступ используя знакомый нам метод `getAttribute`.
```js
a.getAttribute('data-id');
```
Я знаю, что у меня есть data-id, и прямо вот так вот data-id я могу вытащить и использовать.

Либо я могу использовать `setAttribute` и сказать, что был один, а теперь пускай там будет значение шесть. 
```js
a.setAttribute('data-id', '6');
```

data-атрибуты хранятся в специальной коллекции,
которая называется `dataset`. 
```js
a.dataset
```
Мы получаем некий объект, который называется `DOMStringMap`, и в нем лежат все наши data-атрибуты без префикса дат.

Соответственно, мы можем обратиться к dataset, сказать, что пускай будет теперь наш id равен чему-то.
```js
a.dataset.id = 10;
```

Есть мнение, что использование `dataset` менее быстрое с точки зрения производительности,
чем `getAttribute`, `setAttribute`. 