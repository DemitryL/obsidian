Говоря про асинхронную работу в JavaScript, нужно для начала определиться с тем, о чем идет речь, о том, в чем разница между синхронной и асинхронной работой.

Давайте взглянем сразу на небольшой пример. 
```js
console.log('Hi there, me first');

setTimeout(() => console.log('When is my turn?'), 0);

console.log('Am I last in the queue?');
```
У меня есть три console.log. Два из них просто так вызываются, третий у меня завернут в `setTimeout`.  При этом таймер у меня установлен на ноль секунд, то есть я ожидаю, что этот console вроде как должен выполниться сразу.

`SetTimeout`, напомню, он позволяет нам выполнить функцию, которую мы передаем в качестве первого аргумента, спустя то время, которое мы указываем
в качестве второго параметра. 

Если мы выполним наш файл, то мы увидим, что как и ожидается, сначала печатается сообщение первого console.log, затем печатаются сообщения последнего console.log и только потом, несмотря на ноль секунд, у нас отработает console.log, который был посерединке.

В чем здесь секрет, давайте попробуем разобраться. Мы уже с вами говорили про очередь вызова функции, так называемый `collback, collback Stask, Stask` вызова функции.  

Представим, что у нас опять же три console.log, без каких-либо `collback`.  Как у нас будет происходить работа? У нас первая операция попадетв callback Stack. Она тут же выполнится и где-нибудь в console напечатается на наше сообщение, потом следующее сообщение попадет в `Stask` вызова функции, также напечатается где-то в console. Третья и так далее, то есть они просто вот так синхронно, друг за дружкой отработают, и всё будет ровно то, как мы ожидаем.

Когда мы работаем с какой-либо асинхронностью, когда мы включаем таймер, например, это уже сразу идет речь
про асинхронность. У нас картины усложняются. Мы должны держать в голове не только история о том,
что у нас есть некая очередь вызовов, у нас добавляется помимо этой очереди вызовов еще некое троевещие.

![[sl.png]]

Вот у меня первый console.log, он попадает в `Stask` вызовов функции, здесь у нас никакой
особо очереди нету, функция сразу выполняется
и на печать у нас уходит. Дальше у нас идет `setTimeout`. Тут в независимости от того,
сколько установлено у него времени: сто миллисекунд, ноль миллисекунд, но сколько-то есть, за счет того, что здесь идет некая синхронность, и в данном случае используется метод из браузерного API, то оно уходит в это самое стороннее API. 

Оно будет находиться в этом отдельном stack какое-то время, в данном случае то время,
которое у нас указано здесь. Как только это время закончится, она у нас не сразу выполняется, она у нас сначала попадает
в некую очередь, так называемую task queue,
очередь задач. 

Пока `collback` стоит свободен, значит туда что-то из нашей программы должно поместиться, если, конечно, есть, если у нас код есть какой-то.

Но работа заключается в следующем. `Collback Stask` освободился в тот момент, когда наш путешественник перешел в `WebAPI`, так как `Coolback Stask` был свободен, он заполнился тем, что у нас есть в синхронных операциях.

У меня сначала будут выполняться все синхронные задачи. Только, когда синхронных
задач не осталось, задачи из task queue начнут перетекать по очереди в `Coolback Stask` и уже выполняться, в данном случае печататься на console.
