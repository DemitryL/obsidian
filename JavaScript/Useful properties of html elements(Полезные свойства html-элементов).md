Работая с HTML-узлами, мы работаем с разными их свойствами и методами, и в частности нам не нужно знать полный список всего того, что есть, нам нужно иметь в загашнике какой-то основной набор и по необходимости обращаться к документации, чтобы узнать о каких-то
дополнительных свойствах.

```html
<div id='block'>
 <a href="#">Link 1</a>
 <a href="#">Link 2</a>
 <div>
  <div id="too">Block 2</div>
 </div>
</div>
```
Ранее мы всегда искали через `document`, и сейчас у меня есть некий блок. Я хочу его выбрать, а дальше уже искать внутри него.

Kак мне это сделать?
```js
const block1 = document.querySelector('#block');

const block2 = block1.querySelector('#too');
```
У меня сам блок выбран в данном случае
через `querySelector`. Дальнейшие поиски я уже могу делать в рамках `block1`. Допустим, я могу сказать, что мой `block2`.  Я буду искать уже ни в рамках документа, я точно ожидаю, что он внутри `block1` и буду искать его в рамках `block1`.  

Единственное, здесь есть нюансы. Мы не можем в рамках любого элемента, если только это не документ, искать через методы, допустим, `getElementById`, также мы не можем
искать `ByName`. 

Такое ограничение у нас есть, но обычный `querySelector` мы вполне можем использовать и здесь.
```js
const block2 = block1.querySelector('#too');
```

Соответственно, искать иногда бывает нужно и во вложенных элементах, такая штука часто пригождается. 

Следующая штука, это некое интересное свойство, которое есть также у каждого элемента, оно называется `getBoundingClientRect()`.  По сути, даже не свойство, это метод, который вызывается.

Если мы посмотрим, что нам возвращает,
он нам возвращает некую информацию о геометрическом положении элемента `block 2`.
```js
console.log(block2.getBoundingClientRect());
```
вот он у нас и вот у нас некий `DOMRect`, который дал нам вот этот метод `getBoundingClienRect`. Что у нас здесь есть? Во-первых, у нас есть информация о положении нашего элемента на экране. Значение bottom, left, right и top,
это, по сути, точки нахождения. 

Верхнее левое значение - это у нас
значение top и left. Значение bottom и right, соответственно, нижнее правое значение.

То есть мы однозначно знаем, благодя этим координатам, где находится элемент, иногда это нужно в различных вычислениях. 

Следующая штука, которая бывает также полезна, она называется, опять же любой элемент, мы можем выбрать и взять встроенный метод, которыйназывается `insertAdjacentHTML`.
```js
block2.insertAdjacentHTML('')
```
Это некий метод, который пзволяет нам
динамически создавать разметку. У него два параметра, первым параметром он принимает информацию о том, куда мы хотим всё это дело вставить.

У нас четыре значения. У нас есть до и после чего-то, соответственно, есть начала элемента
и конец элемента. 
```js
const x = 1;

block2.insertAdjacentHTML('aftered', `
 <h2 class="subtitle">Text</h2>
 <p>${x}</p>
`)
```
Схематически использование этого
метода добавит мне в разметку в документы новую историю. 

Если бы я использовал здесь другое значение,
допустим, `afterbegin`, как только начался. Но получается, что вставлю я в него, внутрь.

Еще один метод я хотел показать. Метод называется `closest`, давайте посмотрим. 
```js
console.log(block2.closest('div'));
```
В данном случае  эта штука, она позволяет определить по любому CSS-селектору, есть ли ближайший родитель с определенными параметрами. 
