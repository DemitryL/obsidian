Одним из интересных особенностей современного синтаксиса JavaScript является оператор троеточие. 

Его иногда называют spread-оператор, иногда называют rest-оператор, иногда оператором остатка, иногда оператором распространения, то есть, наверное, у этого оператора больше всего названий.

Можно просто называть оператор-многоточие.

Давайте посмотрим в том числе, почему возникла такая путаница. Во многом потому что разные вещи
он сам по себе может сделать. 

Опять же у нас есть некий массив, и мы можем захотеть создать новый массив какой-нибудь. Допустим, `arr2`, и я хочу добавить в новый массив 
какие-то новые значения, но хочу в то же самое время получить все те значения которые у меня были раньше.
```js
const cities = ['Madrid', 'Amsterdam', 'Paris', 'Kiev'];

const arr2 = ['Riga', ...cities, 'Moscow'];
console.log(arr2);
```
Но у нас есть оператор троеточие. Что по факту он сделает? Он возьмёт и извлечет все эти элементы, и положит их в плоском виде так, как будто бы они просто лежали.

Поэтому в случае с созданием массива, мы взяли полностью весь предыдущий массив, при этом взяли только его элементы не ссылаясь никак по ссылке, просто получили элементы, и у нас будет новый массив, который будет содержать всё то, что было ранее, но до всего добавится Рига, после всего добавится Москва.

Таким образом можем извлекать разные массивы.

------
Другой пример с данным оператором, это если мы работаем с объектом.
```js
const dev = {
 id: 1,
 fullName: 'John Doe',
 skills: ['HTML', 'CSS', 'JavaScript'],
 area: 'frontend',
};

const dev2 = { ... dev1 };
```
Здесь, по сути, происходит то же самое,
что в предыдущем примере. Каждая пара ключ-значения берет сюда и распаковывается. 

Мы получим все те же самые ключи внутри нового объекта, и они никаким образом не будут
связаны со старым нашим объектом. 

Мы может в этом убедиться. Возьмем у `dev2`, изменим его идентификатор на 18. Возьмем до кучи, изменим ему `fullname`.  Возьмем Михаила, и мы ожидаем, что они у нас сохраняются не по ссылке, это значит, что `dev1` должен
остаться без изменений, а `dev2` должен эти изменения получить.
```js
dev2.id = 18;
dev2.fullName = 'Mikhail';
```

Это то, что касалось оператора извлечения. Мы извлекли сначала массив, потом извлекли объект.

-----
Но у нас еще есть история, связанная с работой? с функциями.

Я создам функцию, назову ее sum, и я могу не знать, сколько элементов мне придет на сложение. Понятно, если два, всё окей. Но если их будет 3, 4, 5, 10, непредсказуемое значение. 

Здесь я могу тоже использовать Spread-оператор и поставить любое абсолютно имя, но распространено имя `args`, в сокращении от аргументов, опять же это просто параметр.
```js
// args []
function sum(a, b, ...args) {}
```
То есть то же самое, как если бы я написал 1, 2, 3 и так далее. 1 и 2 очевидно попадут в наши параметры a и b. Все оставшиеся элементы,
они попадут в этот самый args.

Но args всегда в данном случае массив. Это пометим, что args у нас является массивом. Причем в данном случае массивом
с непредсказуемым количеством элементов. 

Если я передам всего два элемента, этот массив всегда будет пустым. Если я передам больше 2 элементов, там 3 элемента, значит у меня будет массив с 1 числом, 4 элемента, массив с 2 числами
и так далее. 

```js
function sum(a ,b, ...args) {
 let result = a + b;
 for(let i = 0; i < args.length; i++) {
  result += args[i]; 
 }
 return result;
};

console.log(sum(4, 3)); // 7
console.log(sum(4, 3, 1)); // 8
console.log(sum(4, 3, 1, 2)); // 10
```
Допустим, я могу изначально могу создать некую переменную Результат, `result`, сказать, что этот `result` изначально равен а + b.  А дальше взять цикл, и сказать, что пока у нас в моем массиве args хоть что-то есть, мы будем выполнять этот цикл, и внутри цикла мы будем брать наш текущий результат, и будем прибавлять к нему, текущему значению, элементы нашего массива.

По результатам выполнения нашего цикла мы просто вернем полученный результат
во внешний мир.

Если у нас массив пустой, этот цикл не выполнится ни разу, мы просто получим сложение первых двух чисел.

В данном случае, если до этого мы
использовали оператор распространения, мы используем теперь как оператор остатка и всё, что осталось от того, что у нас дополнительно, да, плюс, что мы еще не задействовали, попадает в одну переменную, и мы можем с ней аккуратненько работать.

Вот такой вот интересный Spread-оператор.