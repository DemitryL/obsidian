Самое интересное начинается, когда мы хотим обрабатывать какие-то [события в браузере](https://developer.mozilla.org/ru/docs/Web/Events), когда пользователь куда-то кликнул, когда он куда-то навел мышью, когда он куда-то проскролил,
когда случилось еще что-либо угодное, что-то он напечатал и так далее.

Давайте посмотрим, как мы можем на элемент навесить какое-то событие. 
```html 
<h1 onclick="fn1()">Title text</h1>
```
```js
const title = document.querySelector('h1');

function fn1() {
 console.log('event!!!');
}
```
Вот у нас есть нечто на странице, и мы можем написать здесь атрибут, допустим, `onclick`, сказать, что в момент клика у нас будет отрабатывать наша `fn1`.

То есть так можно абсолютно любое событие навесить, но так делать не стоит. А пока мы не работаем framework, вроде `React` или `Vue`, то через атрибуты HTML тегов, мы не должны навешивать обработчики событий, это плохая практика, так мы стараемся не делать.

Как мы будем стараться делать, есть два других способа.

У нас есть здесь возможность через тот же самый `on` получить самые разные события, опять же из того списка-справочника. 
```js
title.onmouseenter = fn1;
```
По сути, это событие hover, мы можем сказать, что привяжи нам это событие к функции `fn1`, не вызывая ее здесь. 

Любая ссылка, любое событие из этого справочника с префиксом `on` `onclick, oncontextmenu, ondblclick, onmousedown, onmouseenter, onmouseleave` и так далее.

Любое из этих событий мы можем взять и через точку мы можем оперировать к нашему элементу, и сослаться на существующую функцию. 

Но есть и третий способ, как раз который будет у нас более предпочтительным.
```js
title.addEventListener('click', fn1);
```
Mы указываем два параметра. Первый, мы говорим, что за тип события, а дальше функция. 
Лучше, чтобы эта функция хранилась во вне и просто передать ее.

