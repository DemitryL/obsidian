Мы уже умеем работать с обычными массивами, 
с точки зрения поиска и проверки элемента, есть он там или нет. 

Допустим, у нас, если есть массив городов, мы можем методом `includes` проверить, есть ли там тот или иной элемент и получим истину или ложь, в зависимости от того, есть тот иной элемент на странице.
```js
const cities = ['London', 'Paris', 'Madrid', 'Lisboa'];
cities.includes('Madrid'); // true
```

Либо мы можем быстренько найти позицию того или иного элемента, соответственно, передав ему
опять же название. Если элемента нет, мы получим -1, либо в данном случае мы получим позицию, это индекс.
```js
cities.indexOf('Paris'); // 1
cities.indexOf('Moscow'); // -1
```

Но окей, с этим мы знакомы, а как быть с коллекциями, если мы хотим проверить
тот или иной элемент или узнать его позицию.

Здесь есть соответствующие методы.
```js
const developers = [
 {
  id: 1,
  fullName: 'John Doe',
  skills: ['HTML', 'CSS', 'JavaScript'],
  area: 'frontend',
 },
 {
  id: 2,
  fullName: 'Adam Smith',
  skills: ['HTML', 'CSS', 'JavaScript', 'React'],
  area: 'frontend',
 },
 {
  id: 3,
  fullName: 'Will Dowson',
  skills: ['HTML', 'PHP', 'Laravel'],
  area: 'backend',
 },
 {
  id: 4,
  fullName: 'Sam Wilson',
  skills: ['HTML', 'CSS', 'JavaScript', 'PHP'],
  area: 'fullstack',
 },
];

developers.find(item => item.area === 'frontend');
```
Или есть ли у меня сотрудник, который
занимается `frontend`, хоть один?  

Мы обращаемся к нашей коллекции
и используем метод `find`. Find, как и многие другие методы, принимает у нас функцию.

Логика какая: метод поиска остановится в том случае, когда он найдет первый элемент,
соответствующий тому условию, которое я записываю, в данном случае area равна `frontend`.

Как только он его нашел, в данном случае на первой же позиции, отработка этих функций остановится, в ответ я получу полностью этот элемент, не истину или ложь, как было
в случае с `includes`, а именно полностью этот элемент, и дальше смогу с ним что-либо сделать.

Мы получили полностью объект. Что будет, если мы
попробуем поискать то, чего у нас нету, допустим, как-то по-другому забьем эту историю. Мы получим `undefined`. 

Если идет какая-то вложенная история со скиллами, допустим, я хочу найти кого-то,
у кого есть знания react.
```js
developers.find((item) => item.skills.includes('React'));
```
А нам как раз и нужно, чтобы эта функция вернула true.  Как только она вернула нам true, мы найдем нужный нам элемент.

Если нам нужен индекс, то метод find
нам не совсем подойдет, но история будет прям
полностью идентичная. 
```js
developers.findIndex((item) => item.skills.includes('React')); // 1
```
Если мы найдем специалиста, мы получим его индекс. Если вдруг я буду искать по чему-то тому, что опять же у меня не присутствует, я получу -1, как и в случае с обычным `indexOf`.

Поэтому каждый раз, когда нам нужно что-то искать в коллекции, необязательно это дело фильтровать, есть современные способы по поиску `find` и `findIndex`, пользуемся на здоровье.