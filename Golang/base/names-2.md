# Комментарии к предложениям.

Комментарии, документирующие заявления, должны быть полными предложениями, даже если это кажется немного излишним. Такой подход позволяет им хорошо форматироваться при извлечении в документацию godoc. Комментарии должны начинаться с названия описываемой вещи и заканчиваться точкой:

```go
// Request represents a request to run a command.
type Request struct { ...

// Encode writes the JSON encoding of req to w.
func Encode(w io.Writer, req *Request) { ...
```

## Контексты

Значения контекста. Тип контекста содержит учетные данные безопасности, информацию о трассировке, сроки и сигналы отмены через API и границы процессов. Программы Go явно передают контексты по всей цепочке вызовов функций от входящих RPC и HTTP-запросов к исходящим запросам.

Большинство функций, использующих контекст, должны принимать его в качестве первого параметра:
```
func F(ctx context.Context, /* other arguments */) {}
```

Функция, которая никогда не зависит от запроса, может использовать контекст. Background(), но ошибайтесь в сторону передачи контекста, даже если вы думаете, что вам это не нужно. По умолчанию используется передача контекста; Используйте только контекст. Background() напрямую, если у вас есть веская причина, по которой альтернатива является ошибкой.


Не добавляйте член Context к типу структуры; Вместо этого добавьте параметр CTX в каждый метод того типа, который должен его передать. Единственное исключение составляют методы, подпись которых должна совпадать с интерфейсом в стандартной библиотеке или в библиотеке стороннего производителя.

Не создавайте пользовательские типы контекста и не используйте в сигнатурах функций интерфейсы, отличные от контекста.

Если у вас есть данные приложения для передачи, поместите их в параметр, в получатель, в глобальные переменные или, если они действительно принадлежат к ним, в значение Context.

Контексты неизменяемы, поэтому можно передавать один и тот же ctx нескольким вызовам, которые используют один и тот же срок, сигнал отмены, учетные данные, родительскую трассировку и т. д.

## Копирование

Чтобы избежать неожиданного сглаживания, будьте осторожны при копировании структуры из другого пакета. Например, байты. Тип буфера содержит []байтовый срез. Если вы копируете буфер, срез в копии может быть псевдонимом массива в исходном коде, что приведет к неожиданным последствиям последующих вызовов методов.


Как правило, не копируйте значение типа T, если его методы связаны с типом указателя *T.


## Крипто Рэнд

Не используйте пакет math/rand для генерации ключей, даже одноразовых. В незасеянном состоянии генератор полностью предсказуем. Засеяно со временем. Наносекунды(), есть всего несколько бит энтропии. Вместо этого используйте Reader от crypto/rand, и если вам нужен текст, выведите его в шестнадцатеричный или base64:

```go
import (
    "crypto/rand"
    // "encoding/base64"
    // "encoding/hex"
    "fmt"
)

func Key() string {
    buf := make([]byte, 16)
    _, err := rand.Read(buf)
    if err != nil {
        panic(err)  // out of randomness, should never happen
    }
    return fmt.Sprintf("%x", buf)
    // or hex.EncodeToString(buf)
    // or base64.StdEncoding.EncodeToString(buf)
}
```

## Объявление пустых срезов

При объявлении пустого среза отдайте предпочтение
```
var t []string
```
над
```
t := []string{}
```

Первый объявляет нулевое значение среза, а второй — не нулевое, но нулевое. Они функционально эквивалентны — их len и cap равны нулю, — но предпочтительным стилем является нулевой срез.

Обратите внимание, что существуют ограниченные обстоятельства, в которых предпочтение отдается срезу без нуля, но нулевой длины, например при кодировании объектов JSON (срез nil кодируется как null, в то время как []string{} кодируется в массив JSON []).

При проектировании интерфейсов избегайте различий между нулевым срезом и ненулевым срезом нулевой длины, так как это может привести к незначительным ошибкам программирования.

## Строки ошибок

Строки ошибок не должны быть заглавными (если только они не начинаются с имен собственных или аббревиатур) или заканчиваться знаками препинания, поскольку они обычно печатаются в другом контексте. То есть использовать fmt. Errorf("что-то плохое") не fmt. Errorf("Что-то плохое")), так что log.Printf("Reading %s: %v", filename, err) форматируется без ложной заглавной буквы в середине сообщения. Это не относится к логированию, которое неявно ориентировано на строки и не объединено в других сообщениях.

## Время жизни горутина

Когда вы создаете горутины, четко указывайте, когда они завершаются и завершаются ли вообще.

Горутины могут утекать из-за блокировки отправленных или получаемых каналов: сборщик мусора не завершит горутину, даже если каналы, на которых она заблокирована, недоступны.

Даже если горутины не протекают, если оставить их в полете, когда они больше не нужны, это может привести к другим тонким и трудно диагностируемым проблемам. Посылает по закрытым каналам панику. Изменение все еще используемых входных данных «после того, как результат не нужен» все еще может привести к гонке данных. А если оставить горутины в полете на произвольно долгое время, это может привести к непредсказуемому использованию памяти.

Постарайтесь сделать параллельный код достаточно простым, чтобы время жизни goroutine было очевидным. Если это просто невозможно, задокументируйте, когда и почему выполняются горутины.

## Обработка ошибок

Не отбрасывайте ошибки с помощью _ переменных. Если функция возвращает ошибку, проверьте ее, чтобы убедиться, что функция выполнена успешно. Обработайте ошибку, верните ее или, в действительно исключительных ситуациях, паникуйте.

## Импорт

Избегайте переименования импорта, за исключением случаев, когда это позволяет избежать совпадения имен; Хорошие имена пакетов не должны требовать переименования. В случае коллизии предпочтите переименовать наиболее локальный или специфичный для проекта импорт.

Импорт организован в группы, между ними должны быть пустые строки. Стандартные библиотечные пакеты всегда находятся в первой группе.

```go
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/foo/bar"
    "rsc.io/goversion/version"
)
```

##  Импорт пустого места

Пакеты, которые импортируются только из-за их побочных эффектов (используя синтаксис import _ "pkg"), должны импортироваться только в основном пакете программы или в тестах, которые их требуют.

## Точка

Импорт . Форма может быть полезна в тестах, которые из-за циклических зависимостей не могут быть включены в тестируемый пакет:
```go
package foo_test

import (
    "bar/testutil" // also imports "foo"
    . "foo"
)
```

В этом случае тестовый файл не может быть в пакете foo, потому что он использует bar/testutil, который импортирует foo. Поэтому мы используем форму 'import ', чтобы позволить файлу притворяться частью пакета foo, хотя это не так. За исключением этого единственного случая, не используйте импорт. в ваших программах. Это значительно затрудняет чтение программ, поскольку неясно, является ли имя, такое как Quux, идентификатором верхнего уровня в текущем пакете или в импортированном пакете.

## Внутриполосные ошибки

В C и подобных языках функции часто возвращают такие значения, как -1 или null, чтобы сообщить об ошибках или отсутствующих результатах:

```
// Lookup returns the value for key or "" if there is no mapping for key.
func Lookup(key string) string

// Failing to check for an in-band error value can lead to bugs:
Parse(Lookup(key))  // returns "parse failure for value" instead of "no value for key"
```

Поддержка в Go нескольких возвращаемых значений является лучшим решением. Вместо того чтобы требовать от клиентов проверки значения внутриполосной ошибки, функция должна возвращать дополнительное значение, указывающее, допустимы ли другие возвращаемые значения. Это возвращаемое значение может быть ошибкой или логическим значением, когда объяснение не требуется. Это должно быть окончательное возвращаемое значение.

```
// Lookup returns the value for key or ok=false if there is no mapping for key.
func Lookup(key string) (value string, ok bool)
```

Это предотвратит неправильное использование результата вызывающим абонентом:

```
Parse(Lookup(key))  // compile-time error
```

И поощряет более надежный и читабельный код:

```
value, ok := Lookup(key)
if !ok {
    return fmt.Errorf("no value for %q", key)
}
return Parse(value)
```

Это правило применяется к экспортируемым функциям, но также полезно для неэкспортированных функций.

Возвращаемые значения, такие как nil, "", 0 и -1, хороши, когда они являются допустимыми результатами для функции, то есть когда вызывающему объекту не нужно обрабатывать их иначе, чем другие значения.

Некоторые стандартные библиотечные функции, такие как функции пакета "strings", возвращают внутриполосные значения ошибок. Это значительно упрощает код для работы со строками за счет большего усердия со стороны программиста. В общем случае, код Go должен возвращать дополнительные значения для ошибок.

## Отступ в потоке ошибок

Постарайтесь сохранить минимальный отступ в обычном пути к коду и сделайте отступ при обработке ошибок, разобравшись с ними в первую очередь. Это улучшает читаемость кода, позволяя визуально быстро сканировать нормальный путь. Например, не пишите:

```
if err != nil {
    // error handling
} else {
    // normal code
}
```
 Вместо этого напишите:
```
if err != nil {
    // error handling
    return // or continue, etc.
}
// normal code
```

Если оператор if имеет оператор инициализации, например:
```
if x, err := f(); err != nil {
    // error handling
    return
} else {
    // use x
}
```
Тогда для этого может потребоваться переместить объявление короткой переменной в отдельную строку:
```
x, err := f()
if err != nil {
    // error handling
    return
}
// use x
```

## Инициалы

Слова в именах, которые являются аббревиатурами или аббревиатурами (например, «URL» или «NATO»), имеют постоянный регистр. Например, "URL" должен отображаться как "URL" или "url" (как в "urlPony" или "URLPony"), а не как "Url". В качестве примера: ServeHTTP, а не ServeHttp. Для идентификаторов с несколькими инициализированными "словами" используйте, например, "xmlHTTPRequest" или "XMLHTTPRequest"

Это правило также применимо к "ID", когда оно является сокращением от "identifier" (что встречается практически во всех случаях, когда это не "id", как в "ego", "superego"), поэтому пишите "appID" вместо "appId".

Код, сгенерированный компилятором буфера протокола, исключается из этого правила. Код, написанный человеком, соответствует более высоким стандартам, чем машинный код.

## Интерфейсы

Интерфейсы Go обычно относятся к пакету, использующему значения типа интерфейса, а не к пакету, реализующему эти значения. Реализующий пакет должен возвращать конкретные типы (обычно указатель или структуру): таким образом, новые методы могут быть добавлены в реализации без необходимости обширного рефакторинга.

Не определяйте интерфейсы на стороне разработчика API "для имитации"; вместо этого спроектируйте API таким образом, чтобы его можно было протестировать с помощью общедоступного API реальной реализации.

Не определяйте интерфейсы до того, как они будут использованы: без реалистичного примера использования слишком сложно понять, нужен ли интерфейс вообще, не говоря уже о том, какие методы он должен содержать.

```
package consumer  // consumer.go

type Thinger interface { Thing() bool }

func Foo(t Thinger) string { … }
```
```
package consumer // consumer_test.go

type fakeThinger struct{ … }
func (t fakeThinger) Thing() bool { … }
…
if Foo(fakeThinger{…}) == "x" { … }
```
```
// DO NOT DO IT!!!
package producer

type Thinger interface { Thing() bool }

type defaultThinger struct{ … }
func (t defaultThinger) Thing() bool { … }

func NewThinger() Thinger { return defaultThinger{ … } }
```

Вместо этого верните конкретный тип и позвольте потребителю имитировать реализацию производителя.

```
package producer

type Thinger struct{ … }
func (t Thinger) Thing() bool { … }

func NewThinger() Thinger { return Thinger{ … } }
```

## Длина

В коде Go нет жесткого ограничения длины строки, но избегайте неудобно длинных линий. Точно так же не добавляйте разрывы строк, чтобы строки были короткими, когда они более удобочитаемы, например, если они повторяются.

В большинстве случаев, когда люди переносят строки «неестественно» (скажем, в середине вызовов функций или объявлений функций, хотя есть некоторые исключения), перенос был бы ненужным, если бы у них было разумное количество параметров и достаточно короткие имена переменных. Длинные очереди, кажется, сочетаются с длинными именами, и избавление от длинных имен очень помогает.

Другими словами, разбивайте строки из-за семантики того, что вы пишете (как правило), а не из-за длины строки. Если вы обнаружите, что в результате получаются слишком длинные строки, измените имена или семантику, и вы, вероятно, получите хороший результат.

Это, собственно, точно такой же совет о том, какой длины должна быть функция. Не существует правила «никогда не иметь функцию длиной более N строк», но определенно есть такая вещь, как слишком длинная функция и слишком повторяющиеся крошечные функции, и решение состоит в том, чтобы изменить границы функций, а не начинать считать строки.

## Смешанные заглавные

Это применимо даже в том случае, если это нарушает соглашения на других языках. Например, неэкспортированная константа — maxLength, а не MaxLength или MAX_LENGTH.

## Именованные параметры результата

Рассмотрим, как это будет выглядеть в godoc. Именованные параметры результата, такие как:
```
func (n *Node) Parent1() (node *Node) {}
func (n *Node) Parent2() (node *Node, err error) {}
```
будет повторяться в godoc; Лучше использовать:
```
func (n *Node) Parent1() *Node {}
func (n *Node) Parent2() (*Node, error) {}
```

С другой стороны, если функция возвращает два или три параметра одного типа, или если значение результата не понятно из контекста, добавление имен может быть полезно в некоторых контекстах. Не называйте параметры результата только для того, чтобы избежать объявления var внутри функции; это идет на компромисс между незначительной краткостью реализации и ненужной многословностью API.

```
func (f *Foo) Location() (float64, float64, error)
```
: менее понятно, чем:
```
// Location returns f's latitude and longitude.
// Negative values mean south and west, respectively.
func (f *Foo) Location() (lat, long float64, err error)
```

Голые возвраты допустимы, если функция представляет собой несколько линий. Если это функция среднего размера, четко указывайте возвращаемые значения. Следствие: не стоит называть параметры результата только потому, что это позволяет использовать голые возвраты. Ясность документов всегда важнее, чем сохранение одной-двух строк в вашей функции.

Наконец, в некоторых случаях вам нужно назвать параметр result, чтобы изменить его в отложенном замыкании. Это всегда нормально.


## Голые возвраты

Оператор return без аргументов возвращает именованные возвращаемые значения. Это называется «голым» возвратом.

```
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}
```

## Комментарии к пакету

Комментарии к пакету, как и все комментарии, которые должны быть представлены godoc, должны отображаться рядом с предложением пакета, без пустой строки.

```
// Package math provides basic constants and mathematical functions.
package math
```
```
/*
Package template implements data-driven templates for generating textual
output such as HTML.
....
*/
package template
```

Для комментариев типа "package main" можно использовать другие стили комментариев после двоичного имени (и оно может быть заглавным, если оно идет первым), например, для пакета main в директории seedgen вы можете написать:
```
// Binary seedgen ...
package main
```
или
```
// Command seedgen ...
package main
```
или
```
// Program seedgen ...
package main
```
или
```
// The seedgen command ...
package main
```
или
```
// The seedgen program ...
package main
```
или
```
// Seedgen ..
package main
```

Это примеры, и разумные варианты их приемлемы.

Обратите внимание, что начало предложения со строчной буквы не входит в число приемлемых вариантов комментариев к пакету, так как они общедоступны и должны быть написаны на правильном английском языке, включая написание первого слова предложения с заглавной буквы. Если двоичное имя является первым словом, его использование должно быть написано с заглавной буквы, даже если оно не строго соответствует написанию вызова командной строки.

## Имена

Все ссылки на имена в вашем пакете будут выполняться с использованием имени пакета, поэтому вы можете опустить это имя в идентификаторах. Например, если вы находитесь в пакете chubby, вам не нужен тип ChubbyFile, который клиенты будут записывать как chubby. Пухлый файл. Вместо этого назовите тип File, который клиенты будут записывать как chubby. Файл. Избегайте бессмысленных имен пакетов, таких как util, common, misc, api, types и interfaces.

## Значения передач

Не передавайте указатели в качестве аргументов функции только для экономии нескольких байтов. Если функция ссылается на свой аргумент x только как *x, то аргумент не должен быть указателем. К распространенным примерам этого относится передача указателя на строку (*string) или указателя на значение интерфейса (*io. Читатель). В обоих случаях само значение имеет фиксированный размер и может быть передано напрямую. Этот совет не относится к большим структурам или даже к маленьким структурам, которые могут расти.

## Имена получателей

Имя получателя метода должно отражать его идентичность; часто достаточно одно- или двухбуквенной аббревиатуры его типа (например, «c» или «cl» для «Client»). Не используйте общие имена, такие как "me", "this" или "self", идентификаторы, типичные для объектно-ориентированных языков, которые придают методу особое значение. В Go получатель метода является просто еще одним параметром и, следовательно, должен быть назван соответственно. Название не обязательно должно быть таким же описательным, как у аргумента метода, поскольку его роль очевидна и не служит документальной цели. Он может быть очень коротким, так как будет отображаться почти в каждой строке каждого метода типа; Привычность допускает краткость. Будьте также последовательны: если вы называете приемник «c» в одном методе, не называйте его «cl» в другом.


## Тип ресивера

Выбор между использованием значения или указателя в методах может быть сложным, особенно для начинающих программистов Go. Если вы сомневаетесь, используйте указатель, но бывают случаи, когда приемник значений имеет смысл, обычно по причинам эффективности, например, для небольших неизменяемых структур или значений базового типа. Несколько полезных рекомендаций:

- Если приемником является карта, функ или тян, не используйте указатель на них. Если получатель является срезом и метод не выполняет срезы или не перераспределяет срез, не используйте указатель на него.
- Если метод должен изменить получатель, то получатель должен быть указателем.
- Если получатель является структурой, содержащей синхронизацию. Мьютекс или аналогичное синхронизирующее поле, на получателе должен быть указатель, чтобы избежать копирования.
- Если получатель представляет собой большую структуру или массив, то более эффективным является получатель указателя. Насколько велик большой? Предположим, что это эквивалентно передаче всех его элементов в качестве аргументов методу. Если он кажется слишком большим, он также слишком велик для получателя.
- Могут ли функции или методы, одновременно или при вызове из этого метода, изменять приемник? Тип значения создает копию получателя при вызове метода, поэтому внешние обновления не будут применяться к этому получателю. Если изменения должны быть видны в исходном приемнике, то приемник должен быть указателем.
- Если получатель является структурой, массивом или срезом, а любой из его элементов является указателем на что-то, что может изменяться, отдайте предпочтение получателю указателя, так как это сделает намерение более понятным для читателя.
- Если получатель представляет собой небольшой массив или структуру, то это, естественно, тип значения (например, что-то вроде времени. Time type), без изменяемых полей и указателей, или просто является простым базовым типом, таким как int или string, имеет смысл использовать приемник значения. Получатель значений может уменьшить количество мусора, который может быть создан; Если значение передается в метод Value, вместо выделения в куче можно использовать копию на стеке. (Компилятор пытается проявить изобретательность, чтобы избежать этого выделения, но не всегда может это сделать.) По этой причине не выбирайте тип приемника значений без предварительного профилирования.
- Не смешивайте типы ресиверов. Выберите указатели или типы структур для всех доступных методов.
- Наконец, если вы сомневаетесь, используйте стрелочный приемник.

## Синхронные функции

Отдайте предпочтение синхронным функциям - функциям, которые возвращают свои результаты напрямую или завершают любые коллбэки или операции канала перед возвратом - вместо асинхронных.

Синхронные функции позволяют локализовать горутины в пределах вызова, что упрощает анализ времени их жизни и позволяет избежать утечек и гонки данных. Кроме того, их проще тестировать: вызывающий абонент может передать входные данные и проверить выходные данные без необходимости опроса или синхронизации.

Если вызывающим объектам требуется больше параллелизма, они могут легко добавить его, вызвав функцию из отдельной горутины. Но довольно сложно, а иногда и невозможно, удалить ненужный параллелизм на стороне вызывающего абонента.

## Полезные неудачи тестов

Тесты должны завершаться неудачей с полезными сообщениями о том, что было не так, с какими входными данными, что на самом деле было получено и что ожидалось. Может показаться заманчивым написать кучу помощников assertFoo, но убедитесь, что ваши помощники выдают полезные сообщения об ошибках. Предположим, что человек, выполняющий отладку неудачного теста, — это не вы и не ваша команда. Типичный тест Go завершается следующим образом:

```
if got != tt.want {
    t.Errorf("Foo(%q) = %d; want %d", tt.in, got, tt.want) // or Fatalf, if test can't test anything more past this point
}
```

Обратите внимание, что порядок здесь актуальный != ожидаемый, и сообщение также использует этот порядок. Некоторые тестовые фреймворки рекомендуют записывать их в обратном порядке: 0 != x, "ожидаемый 0, получил x" и так далее. Го нет.

Если вам кажется, что это слишком много типизации, вы можете захотеть написать тест, управляемый таблицами.

Еще один распространенный метод устранения неоднозначности неудачных тестов при использовании тестового помощника с разными входными данными заключается в том, чтобы обернуть каждый вызывающий объект отдельной функцией TestFoo, чтобы тест завершился неудачей с этим именем:

```
func TestSingleValue(t *testing.T) { testHelper(t, []int{80}) }
func TestNoValues(t *testing.T)    { testHelper(t, []int{}) }
```

В любом случае, ответственность за неудачу лежит на вас с полезным сообщением для тех, кто будет отлаживать ваш код в будущем.

##  Имена переменных

Имена переменных в Go должны быть короткими, а не длинными. Это особенно верно для локальных переменных с ограниченной областью действия. Отдайте предпочтение c вместо lineCount. Предпочитайте i, а не sliceIndex.

Основное правило: чем дальше от его декларирования используется имя, тем более описательным должно быть имя. Для метода ресивера достаточно одной или двух букв. Общие переменные, такие как индексы циклов и считыватели, могут быть одной буквой (i, r). Более необычные вещи и глобальные переменные нуждаются в более описательных названиях.
