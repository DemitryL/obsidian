# Синтаксис в Go основан на синтаксисе Си. Он достаточно стандартный.

----
На что обратить внимание:
- for ...range для различных итерируемых объектов 
- различия в способах объявления переменной
- все типы данных различны
- области видимости
----

В Go нет магии!

## Имена
Имена в Go - тема постоянных дискусий.
Сушестует несколько официальных рекомендаций:
1. **[[names-1]]**
2. **[[names-2]]**
Примером идиоматического кода является стандартная библиотека.
- Обшие рекомендации: имена должны быть короткими и понятными.
- Имена пишутся в PascalCase and camelCase(кроме пакетов).


#### Переменные:
- i,n,s - используются близко
- timeout, req, format - большая область использования 
#### Функции:
- do(), trimPrefix(),scan(),newRequest() - коротко и ясно
- users(), timeout(), string() - геттеры
#### Константы:
- MinTimeout, maxTimeout
#### Пакеты:
- api, http, stats, pg, strconv, context, dns


## Массивы и срезы (array, slice)
- Тип [n]T объявляет массив из n элементов типа <T>.
- Тип []T объявляет срез (slice, слайс) из элементов типа <T>.
- Размер: массивы имеют фиксированную длину, срузы могут измениться динамически.
- Существуют встроенные функции для определения размера и добаления элементов.
- Массивы не могут изменять свой размер.

## Срезы(slice)
- Статья: (Link:)[https://go.dev/blog/slices-intro] , **[[slice]]**
- len(s),cap(s) возвращают длину и емкость
- Может быть инициализирован функцией make() с указанием len и cap.
- Поскольку массивы неизменяемы, то при расширении создается новый массив.
- Может быть "разрезан": s[2:5] вернет новый срез со второго по пятый элемент, НЕ включая последный.

## Ассоциативные массивы (map)
- Статья в официальном блоге: (Link:)[https://blog.golang.org/maps], **[[map]]**
- map - ассоциативный массив, словарь, сопоставляющий каждому ключу значение.
- Ключи уникальны, порядок обхода ключей случайный.
- Синтаксис: var m map[type]type
- Поиск по ключу осуществляется за константное время O(1) и это действительно быстро.
- После объявления переменной необходимо создать ассоциативный массив с помощью функции make().

## Строки(string)
- UTF8 по умолчанию.
- Внутри - структура из двух полей: длина строки и ссылка на массив
- Строки неизменяемы! Нельзя менять отдельные элементы.
- For ...range возвращает два значения: номер байта начала символа и сам символ (тип rune).

## Структуры(struct)
- Структура - тип данных, являющийся именованным набором полей.
type Point struct {
    X int
    Y int
}
- Структура является отдаленным аналогом класса и используется для описания модели данных предметной области.

## Композиция 
- Композиция - возможность встроить один структурный тип в другой с сохранением полей и методов.
type Point struct {
    X float64
    Y float64
}

type Place struct {
    Name string
    Point // встраивание
}
- Своеобразный аналог наследования.

## Методы 
Метод - функция со специальным аргуметом-приемником (receiver)
Нужно запомнить:
- получатель указывается в скобках перед именем функции
- получателем может быть любой тип, кроме встроенного (int, string, bool и пр.).
- получателем может быть как указатель так и значение
    func (c *Cache) Get(key string) string { ... }
    func (c Cache) Get(key string) string { ... }
*Указатели VS Значение.

## Указатели VS Ссылки VS Значения 
Указатель - переменная, содержащая адрес объекта некоторого типа. По умолчанию равна nil.
Ссылка - адрес в памяти некоторого конкретного объекта.
Значение - значение некоторой переменной.
```
var p *int  // указатель на переменную типа int
var i int = 20 // переменная со значением 20
addr := &i   // ссылка на переменную
p = addr  // корректно
fmt.Println(*p)  // разыменование указателя (получение значения)
```
Передача аргумента по значению означает копирование значения переменной, по ссылке - передача адреса

## Интерфейсы
Интерфейсные типы выражают обобщения или абстракции поведения других типов.(Алан Донован)
Из этого следует:
- интерфейс - тип данных
- интерфейс определяет поведение (набор методов) объекта (объявляет контракт)
- контракт интерфейса выполняется неявно
- пустому интерфейсу может быть присвоена переменная любого типа
- "interface{} says nothing." (https://go-proverbs.github.io/)
- ИНТЕРФЕЙСЫ ВЫПОЛНЯЮТСЯ НЕЯВНО!

### Напишем метод, выполняющий контракт интерфейса fmt.Stringer
```go
package main

import (
    "fmt"
)
//- создан тип данных, на базе встроенного
type myInt int

//- для него создан метод String()
func (i myInt) String() string {
    return fmt.Sprintf("Целое число: %d\n", i)
}

func main() {
    var mi myInt = 10
    fmt.Println(mi)
}
// Output: Целое число: 10
```
- таким образом неявно выполнен контракт интерфейса fmt.Stringer

type Stringer interface {
    String() string
}

## Ошибки(err)
- Статья в официяльном блоге: (Link)[https://go.dev/blog/error-handling-and-go] , **[[errors]]
- Ошибка в Go (error) - встроенный тип, интерфейс.
type error interface {
    Error() string
}
- Ошибка трактуется как обычное значение.
- Если функция возвращает ошибку - ее нужно вернуть последним значением.
- Всегда проверяйте наличие ошибки!

## Ошибки(пример)

```go
package main

import ( … )

func main() {
    val, err := envVar("несуществующее_имя_переменной")
    if err != nil {
        log.Fatal(err)
    }
    _ = val
}
// envVar возвращает переменную окружения, заданную по имени. Если переменная не найдена - возвращается ошибка.
func envVar(name string) (string, error) {
    val := os.Getenv(name)
    if val == "" {
        return val, fmt.Errorf("переменная с именем %s не найдена", name)
    }

    return val, nil
}
// Output: 2020/10/02 13:23:36 переменная с именем несуществующее_имя_переменной не найдена
// exit status 1
```

### Ошибки в Go 1.13
- Статья в официальном блоге: (Link)[https://blog.golang.org/go1.13-errors]
- Ошибку можно упаковать в другую ошибку. Таким
образом можно вернуть несколько ошибок вверх по
стеку вызова.
- Для упаковки ошибки fmt.Errorf поддерживает %w.
- Появились методы errors.Is (сравнение со значением
ошибки) и errors.As (сравнение с типом ошибки). Эти
функции поддерживают работу с цепочками, вызывая
метод Unwrap для цепочки ошибок.

## Каналы

Каналы – типизированные проводники, через которые можно передавать и принимать данные с
помощью оператора «<-»

```go
package main

import "fmt"

func main() {
    var ch chan int // переменная типа канал, принимающий int
    ch = make(chan int)

    go func(ch chan<- int) { // канал только на отправку
        ch <- 100
    }(ch)

    val := <-ch // операция чтения или записи блокирует программу
    fmt.Println(val)
}
// OUTPUT: 100
```

### Каналы
- Отличная статья: (Link)[https://go101.org/article/channel.html] 
- Каналы могут быть буферизированными и не
буферизированными.
- Помимо оператора чтения и записи (<-) можно
использовать оператор range для перебора значений.
- Для каналов определены функции len(), cap(), close().
- Операции чтения и записи – блокирующие.
- Запись в закрытый канал – паника.
- Чтение происходит раньше записи.
- Для каналов определён оператор перебора каналов
select (Link)[http://play.golang.org/p/FzONhs4-tae]

## Пакеты
- Пакет – каталог с одним или несколькими Go-файлами.
- Пакет предназначен для организации кода для
повторного использования.
- Пакет «main» является исполняемым.
- В пакеты следует помещать логически связанный код.
- Пакет предназначен для решения одной задачи или
задач одного типа.
- Хорошим образцом пакетов для изучения является
стандартная библиотека.

## Модули
- Серия статей в официальном блоге: (Link)[https://blog.golang.org/using-go-modules]
- Модули – система управления зависимостями
(пакетами), появившаяся в версии 1.11.
- Модули позволяют разрабатывать код вне каталога
«GOPATH».
- Модуль – проект. Чтобы создать модуль, нужно
выполнить «go mod init module.name» в каталоге
проекта. При этом создается файл модуля «go.mod».
- Модули позволяют контролировать версии
зависимостей, хэши зависимостей в файле «go.sum».


## Правила именования пакетов
- Официальные рекомендации: (Link)[https://blog.golang.org/package-names]
- Резюме:
    -- имена должны быть короткими и простыми; идеально
– одно простое слово – time, json, errors, net, http и т.д.
    -- имя пакета должно говорить о его предназначении;
поэтому не следует создавать пакеты utils, useful_stuff
и пр.
    -- имя пакета нужно выбирать так, чтобы оно не мешало именованию объектов внутри пакета.
    -- html.Page, но не htmlpage.Page и не html.htmlpage


## Циклические зависимости

Если пакет A вызывает код из пакета B, пакет B вызывает код из пакета C, а пакет C вызывает код
из пакета A, то образуется циклическая зависимость. Такой код не скомпилируется.

```
package a

import "go-core/3-syntax-two/snippets/pkg/c"

var A = 10
var C = c.C + 10
//===========================================
package b

// где здесь будет ошибка
import "go-core/3-syntax-two/snippets/pkg/a"

var B = a.A + 10
//===========================================
package c

import "go-core/3-syntax-two/snippets/pkg/b"

var C int = b.B + 10
```

## Принципы декомпозиции системы на пакеты
- Разделение (декомпозиция) системы на пакеты
позволяет упростить ментальную модель.
- При декомпозиции я рекомендую руководствоваться
принципом «screaming architecture» - структура пакетов
должна повторять структуру приложения.
- Пакеты должны быть слабо сцеплены друг с другом
(небольшое изменение одного из пакетов, не должно
приводить к серьёзному изменению в других), но
иметь сильную связность (код внутри пакета
логически связан и образует единое целое).
- Пакет решает одну или несколько связанных задач.

### Принципы декомпозиции системы на пакеты
- Одним из вариантов разделения приложения на
пакеты является архитектурный шаблон «ядро и
плагины».
- Хорошим примером организации пакетов является
стандартная библиотека.
- При организации пакетов как набора ортогональных
функциональных подсистем, мы получаем простое и
дешёвое в сопровождении приложение.
- Главная задача архитектора ПО – сделать разработку
максимально дешёвой.

## Архитектура «Ядро и плагины»
- объект сервер подключает необходимые службы (плагины)
- внешние системы (БД, журналы) подключаются как интерфейсы
- добавление новой функциональности означает лишь разработку и подключение нового плагина
