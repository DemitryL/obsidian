# Обработка ошибок и Go

## Введение

Если вы писали какой-либо код Go, вы, вероятно, сталкивались со встроенным типом ошибок. Код Go использует значения ошибок для обозначения аномального состояния. Например, ос. Функция Open возвращает значение ошибки, отличное от nil, когда ей не удается открыть файл.
```
func Open(name string) (file *File, err error)
```

В следующем коде используется os. Открыть, чтобы открыть файл. Если возникает ошибка, он вызывает log. Фатально выводить сообщение об ошибке и останавливаться.
```
f, err := os.Open("filename.ext")
if err != nil {
    log.Fatal(err)
}
// do something with the open *File f
```

Вы можете многое сделать в Go, зная только это о типе ошибки, но в этой статье мы подробнее рассмотрим ошибку и обсудим некоторые хорошие практики обработки ошибок в Go.

## Тип ошибки

Тип ошибки — это тип интерфейса. Переменная ошибки представляет собой любое значение, которое может описывать себя в виде строки. Вот объявление интерфейса:
```
type error interface {
    Error() string
}
```

Тип ошибки, как и все встроенные типы, предобъявлен в блоке universe.

Наиболее часто используемой реализацией ошибок является неэкспортированный тип errorString пакета ошибок.
```
// errorString is a trivial implementation of error.
type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
```

Вы можете построить одно из этих значений с ошибками. Новая функция. Он принимает строку, которую преобразует в строку errors.errorString и возвращает как значение ошибки.
```
// New returns an error that formats as the given text.
func New(text string) error {
    return &errorString{text}
}
```
Вот как можно использовать ошибки. Новые фичи:

```
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return 0, errors.New("math: square root of negative number")
    }
    // implementation
}
```

Вызывающий объект, передающий отрицательный аргумент в Sqrt, получает значение ошибки, отличное от nil (конкретное представление которого — значение errors.errorString). Вызывающий может получить доступ к строке ошибки ("math: квадратный корень..."), вызвав метод Error ошибки или просто выведя ее:

```
f, err := Sqrt(-1)
if err != nil {
    fmt.Println(err)
}
```

Пакет fmt форматирует значение ошибки, вызывая строковый метод Error().

Ответственность за обобщение контекста лежит на реализации ошибки. Ошибка, возвращенная os. Открытые форматы как "open /etc/passwd: permission denied", а не просто "permission denied". Ошибка, возвращаемая нашим Sqrt, заключается в отсутствии информации о недопустимом аргументе.

Чтобы добавить эту информацию, полезной функцией является Errorf пакета fmt. Он форматирует строку в соответствии с правилами Printf и возвращает ее как ошибку, созданную ошибками. Новинка.

```
if f < 0 {
    return 0, fmt.Errorf("math: square root of negative number %g", f)
}
```

Во многих случаях fmt. Errorf достаточно хорош, но поскольку error является интерфейсом, вы можете использовать произвольные структуры данных в качестве значений error, чтобы позволить вызывающим объектам проверить детали ошибки.

Например, наши гипотетические вызывающие объекты могут захотеть восстановить недействительный аргумент, переданный в Sqrt. Мы можем сделать это, определив новую реализацию ошибки вместо использования errors.errorString:

```
type NegativeSqrtError float64

func (f NegativeSqrtError) Error() string {
    return fmt.Sprintf("math: square root of negative number %g", float64(f))
}
```

Затем опытный вызывающий объект может использовать утверждение типа для проверки NegativeSqrtError и специальной обработки, в то время как вызывающие объекты просто передают ошибку в fmt. Распечатайте или запишитесь. Fatal не увидит никаких изменений в поведении.

В качестве другого примера пакет json указывает тип SyntaxError, который указан в json. Функция Decode возвращается, когда обнаруживает синтаксическую ошибку при анализе большого двоичного объекта JSON.

```
type SyntaxError struct {
    msg    string // description of error
    Offset int64  // error occurred after reading Offset bytes
}

func (e *SyntaxError) Error() string { return e.msg }
```

Поле Offset даже не отображается в форматировании ошибки по умолчанию, но вызывающие могут использовать его для добавления информации о файлах и строках в свои сообщения об ошибках:

```
if err := dec.Decode(&val); err != nil {
    if serr, ok := err.(*json.SyntaxError); ok {
        line, col := findLine(f, serr.Offset)
        return fmt.Errorf("%s:%d:%d: %v", f.Name(), line, col, err)
    }
    return err
}
```

(Это немного упрощенная версия реального кода из проекта Camlistore.)

Для интерфейса ошибок требуется только метод Error; Для конкретных реализаций ошибок могут быть дополнительные методы. Например, пакет net возвращает ошибки типа error, следуя обычному соглашению, но некоторые реализации ошибок имеют дополнительные методы, определенные net. Ошибка интерфейса:

```
package net

type Error interface {
    error
    Timeout() bool   // Is the error a timeout?
    Temporary() bool // Is the error temporary?
}
```

Клиентский код может тестировать сеть. Ошибка с утверждением типа и затем отличите временные сетевые ошибки от постоянных. Например, поисковый робот может перейти в спящий режим и повторить попытку, когда обнаруживает временную ошибку, и в противном случае сдаться.

```
if nerr, ok := err.(net.Error); ok && nerr.Temporary() {
    time.Sleep(1e9)
    continue
}
if err != nil {
    log.Fatal(err)
}
```

## Упрощение обработки повторяющихся ошибок

В Go важна обработка ошибок. Дизайн и соглашения языка поощряют явную проверку на наличие ошибок там, где они возникают (в отличие от соглашения в других языках о создании исключений и их иногда перехвате). В некоторых случаях это делает код Go многословным, но, к счастью, есть некоторые методы, которые вы можете использовать, чтобы свести к минимуму повторяющуюся обработку ошибок.

Рассмотрим приложение App Engine с обработчиком HTTP, который извлекает запись из хранилища данных и форматирует ее с помощью шаблона.

```
func init() {
    http.HandleFunc("/view", viewRecord)
}

func viewRecord(w http.ResponseWriter, r *http.Request) {
    c := appengine.NewContext(r)
    key := datastore.NewKey(c, "Record", r.FormValue("id"), 0, nil)
    record := new(Record)
    if err := datastore.Get(c, key, record); err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    if err := viewTemplate.Execute(w, record); err != nil {
        http.Error(w, err.Error(), 500)
    }
}
```

Эта функция обрабатывает ошибки, возвращаемые хранилищем данных. Получите функцию и метод Execute viewTemplate. В обоих случаях он представляет пользователю простое сообщение об ошибке с кодом состояния HTTP 500 («Внутренняя ошибка сервера»). Это выглядит как управляемый объем кода, но добавьте еще несколько обработчиков HTTP, и вы быстро получите множество копий идентичного кода обработки ошибок.

Чтобы уменьшить количество повторений, мы можем определить наш собственный тип HTTP appHandler, который включает возвращаемое значение ошибки:

```
type appHandler func(http.ResponseWriter, *http.Request) error
```

Затем мы можем изменить нашу функцию viewRecord для возврата ошибок:

```
func viewRecord(w http.ResponseWriter, r *http.Request) error {
    c := appengine.NewContext(r)
    key := datastore.NewKey(c, "Record", r.FormValue("id"), 0, nil)
    record := new(Record)
    if err := datastore.Get(c, key, record); err != nil {
        return err
    }
    return viewTemplate.Execute(w, record)
}
```

Это проще, чем оригинальная версия, но пакет http не понимает функции, возвращающие ошибку. Чтобы исправить это, мы можем реализовать http. Метод ServeHTTP интерфейса обработчика в appHandler:

```
func (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if err := fn(w, r); err != nil {
        http.Error(w, err.Error(), 500)
    }
}
```

Метод ServeHTTP вызывает функцию appHandler и отображает пользователю возвращенную ошибку (если таковая имеется). Обратите внимание, что получатель метода, fn, является функцией. (Го может это сделать!) Метод вызывает функцию путем вызова получателя в выражении fn(w, r).

Теперь при регистрации viewRecord с пакетом http мы используем функцию Handle (вместо HandleFunc), так как appHandler - это http. Обработчик (не http. HandlerFunc).

```
func init() {
    http.Handle("/view", appHandler(viewRecord))
}
```

С помощью этой базовой инфраструктуры обработки ошибок мы можем сделать ее более удобной для пользователя. Вместо того, чтобы просто отображать строку ошибки, было бы лучше предоставить пользователю простое сообщение об ошибке с соответствующим кодом состояния HTTP, а полное сообщение об ошибке было бы зарегистрировано в консоли разработчика App Engine для целей отладки.

Для этого мы создаем структуру appError, содержащую ошибку и некоторые другие поля:

```
type appError struct {
    Error   error
    Message string
    Code    int
}
```

Далее мы модифицируем тип appHandler для возврата значений *appError:

```
type appHandler func(http.ResponseWriter, *http.Request) *appError
```

(Обычно ошибочно передавать обратно конкретный тип ошибки, а не ошибку, по причинам, описанным в FAQ Go, но здесь это правильно, потому что ServeHTTP — единственное место, где видят значение и используют его содержимое.)

И заставьте метод ServeHTTP appHandler отображать сообщение appError пользователю с правильным кодом статуса HTTP и записывать полную ошибку в консоль разработчика:

```
func (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if e := fn(w, r); e != nil { // e is *appError, not os.Error.
        c := appengine.NewContext(r)
        c.Errorf("%v", e.Error)
        http.Error(w, e.Message, e.Code)
    }
}
```

Наконец, мы обновляем viewRecord до новой сигнатуры функции и заставляем его возвращать больше контекста, когда он сталкивается с ошибкой:

```
func viewRecord(w http.ResponseWriter, r *http.Request) *appError {
    c := appengine.NewContext(r)
    key := datastore.NewKey(c, "Record", r.FormValue("id"), 0, nil)
    record := new(Record)
    if err := datastore.Get(c, key, record); err != nil {
        return &appError{err, "Record not found", 404}
    }
    if err := viewTemplate.Execute(w, record); err != nil {
        return &appError{err, "Can't display record", 500}
    }
    return nil
}
```

Эта версия viewRecord имеет ту же длину, что и оригинальная, но теперь каждая из этих строк имеет определенное значение, и мы обеспечиваем более дружелюбный пользовательский опыт.

На этом все не заканчивается; Мы можем еще больше улучшить обработку ошибок в нашем приложении. Некоторые идеи:
    - дать обработчику ошибок красивый HTML-шаблон
    - упростить отладку, записав трассировку стека в ответ HTTP, когда пользователь является администратором,
    - написать функцию-конструктор для appError, которая хранит трассировку стека для упрощения отладки,
    - восстановиться после паники внутри appHandler, зарегистрировав ошибку в консоли как «Критическая», сообщив пользователю о том, что произошла серьезная ошибка. Это приятный штрих, позволяющий не подвергать пользователя непостижимым сообщениям об ошибках, вызванных ошибками программирования. Для получения более подробной информации см. статью Отсрочка, паника и восстановление.

## Заключение

Правильная обработка ошибок является важным требованием к хорошему программному обеспечению. Используя методы, описанные в этом посте, вы сможете написать более надежный и лаконичный код Go.
