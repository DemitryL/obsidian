# Go Slices: использование и внутреннее устройство.

## Введение

Тип среза Go обеспечивает удобное и эффективное средство работы с последовательностями типизированных данных. Срезы аналогичны массивам в других языках, но обладают некоторыми необычными свойствами. В этой статье мы рассмотрим, что такое срезы и как они используются.

## Массивы 

Тип среза — это абстракция, построенная на основе типа массива Go, и поэтому, чтобы понять срезы, мы должны сначала разобраться в массивах.

Определение типа массива определяет длину и тип элемента. Например, тип [4]int представляет собой массив из четырех целых чисел. Размер массива фиксирован; Его длина является частью его типа ([4]int и [5]int являются отдельными, несовместимыми типами). Массивы могут быть проиндексированы обычным способом, поэтому выражение s[n] обращается к n-му элементу, начиная с нуля.
```
var a [4]int
a[0] = 1
i := a[0]
// i == 1
```
Массивы не нужно инициализировать явно; Нулевое значение массива — это готовый к использованию массив, элементы которого сами обнуляются:
```
// a[2] == 0, the zero value of the int type
```
Представление [4]int в памяти — это всего лишь четыре целочисленных значения, расположенных последовательно:

Массивы Go являются значениями. Переменная массива обозначает весь массив; он не является указателем на первый элемент массива (как в случае с C). Это означает, что когда вы присваиваете или передаете значение массива, вы создаете копию его содержимого. (Чтобы избежать копирования, вы можете передать указатель на массив, но тогда это будет указатель на массив, а не на массив.) Один из способов думать о массивах — это своего рода структура, но с индексированными, а не именованными полями: составное значение фиксированного размера.

Литерал массива может быть указан следующим образом:
```
b := [2]string{"Penn", "Teller"}
```
Или вы можете попросить компилятор подсчитать элементы массива за вас:
```
b := [...]string{"Penn", "Teller"}
```
В обоих случаях тип b — [2]string.

## Слайсы

Массивы имеют свое место, но они немного негибкие, поэтому вы не встретите их слишком часто в коде Go. Ломтики, однако, повсюду. Они основаны на массивах, чтобы обеспечить большую мощность и удобство.

Спецификация типа среза — []T, где T — тип элементов среза. В отличие от типа массива, тип среза не имеет указанной длины.

Литерал среза объявляется так же, как и литерал массива, за исключением того, что вы опускаете количество элементов:
```
letters := []string{"a", "b", "c", "d"}
```

Срез может быть создан с помощью встроенной функции make, которая имеет сигнатуру,

```
func make([]T, len, cap) []T
```

где T обозначает тип элемента создаваемого среза. Функция make принимает тип, длину и необязательную емкость. При вызове make выделяет массив и возвращает срез, который ссылается на этот массив.

```
var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}
```

Если аргумент capacity опущен, по умолчанию используется указанная длина. Вот более лаконичная версия того же кода:

```
s := make([]byte, 5)
```

Длину и емкость ломтика можно проверить с помощью встроенных функций len и cap.

```
len(s) == 5
cap(s) == 5
```

В следующих двух разделах обсуждается взаимосвязь между длиной и емкостью.

Нулевое значение среза равно нулю. Функции len и cap вернут 0 для нулевого среза.

Срез также может быть сформирован путем «нарезки» существующего среза или массива. Срез выполняется путем указания полуоткрытого диапазона с двумя индексами, разделенными двоеточием. Например, выражение b[1:4] создает срез, включающий элементы с 1 по 3 из b (индексы результирующего среза будут от 0 до 2).

```
b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b
```

Начальный и конечный индексы выражения среза являются необязательными; По умолчанию они равны нулю и длине среза соответственно:

```
// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
```

Это также синтаксис для создания среза с заданным массивом:

```
x := [3]string{"Лайка", "Белка", "Стрелка"}
s := x[:] // a slice referencing the storage of x
```

## Срез внутренностей

Срез — это дескриптор сегмента массива. Он состоит из указателя на массив, длины сегмента и его емкости (максимальной длины сегмента).

Наша переменная s, созданная ранее с помощью make([]byte, 5), структурирована следующим образом:

Длина — это количество элементов, на которые ссылается срез. Емкость — это количество элементов в базовом массиве (начиная с элемента, на который указывает указатель среза). Различие между длиной и емкостью станет ясным, когда мы рассмотрим несколько следующих примеров.

По мере того, как мы делаем срезы s, наблюдайте за изменениями в структуре данных среза и их отношением к базовому массиву:
```
s = s[2:4]
```

При срезе данные среза не копируются. Он создает новое значение среза, указывающее на исходный массив. Это делает операции с срезами столь же эффективными, как и манипулирование индексами массивов. Таким образом, изменение элементов (а не самого среза) повторного среза приводит к изменению элементов исходного среза:
```
d := []byte{'r', 'o', 'a', 'd'}
e := d[2:]
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
```

Ранее мы нарезали s до длины меньше его вместимости. Мы можем вырастить его до полной емкости, нарезав его снова:

```
s = s[:cap(s)]
```

Кусочек не может быть выращен сверх его возможностей. Попытка сделать это вызовет панику во время выполнения, как и при индексировании за пределами среза или массива. Аналогичным образом, срезы не могут быть повторно срезаны ниже нуля для доступа к более ранним элементам массива.

## Выращивание срезов (функции копирования и добавления)

Чтобы увеличить емкость среза, необходимо создать новый, больший по размеру срез и скопировать в него содержимое исходного среза. Этот метод позволяет реализовать динамические массивы из других языков в фоновом режиме. В следующем примере емкость s удваивается путем создания нового среза t, копирования содержимого s в t, а затем присвоения значения среза t s:

```
t := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0
for i := range s {
        t[i] = s[i]
}
s = t
```

Зацикленная часть этой обычной операции упрощается благодаря встроенной функции копирования. Как следует из названия, копирование копирует данные из исходного среза в целевой срез. Он возвращает количество скопированных элементов.

```
func copy(dst, src []T) int
```

Функция копирования поддерживает копирование между срезами разной длины (она будет копировать только до меньшего количества элементов). Кроме того, copy может обрабатывать исходный и целевой срезы, которые используют один и тот же базовый массив, правильно обрабатывая перекрывающиеся срезы.

С помощью копирования мы можем упростить приведенный выше фрагмент кода:
```
t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
```

Распространенной операцией является добавление данных в конец среза. Эта функция добавляет элементы byte к срезу байтов, при необходимости увеличивая срез, и возвращает обновленное значение среза:

```
func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n > cap(slice) { // if necessary, reallocate
        // allocate double what's needed, for future growth.
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}
```

AppendByte можно использовать следующим образом:

```
p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
```

Такие функции, как AppendByte, полезны, потому что они обеспечивают полный контроль над тем, как выращивается срез. В зависимости от характеристик программы, может быть желательно выделять меньшие или большие части, или установить потолок на размер перераспределения.

Но большинству программ не нужен полный контроль, поэтому Go предоставляет встроенную функцию добавления, которая хороша для большинства целей; У него есть подпись

```
func append(s []T, x ...T) []T
```

Функция append добавляет элементы x к концу среза s и увеличивает срез, если требуется большая емкость.

```
a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
```

Чтобы добавить один срез к другому, используйте ... , чтобы развернуть второй аргумент до списка аргументов.

```
a := []string{"John", "Paul"}
b := []string{"George", "Ringo", "Pete"}
a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])"
// a == []string{"John", "Paul", "George", "Ringo", "Pete"}
```

Поскольку нулевое значение среза (nil) действует как срез нулевой длины, вы можете объявить переменную среза, а затем добавить к ней в цикле:
```
// Filter returns a new slice holding only
// the elements of s that satisfy fn()
func Filter(s []int, fn func(int) bool) []int {
    var p []int // == nil
    for _, v := range s {
        if fn(v) {
            p = append(p, v)
        }
    }
    return p
}
```

### Возможный "подвох"

Как упоминалось ранее, повторное разделение среза не создает копию базового массива. Весь массив будет храниться в памяти до тех пор, пока на него больше не будут ссылаться. Иногда это может привести к тому, что программа будет удерживать все данные в памяти, когда требуется только небольшая их часть.

Например, эта функция FindDigits загружает файл в память и ищет в нем первую группу последовательных числовых цифр, возвращая их в виде нового среза.
```
var digitRegexp = regexp.MustCompile("[0-9]+")

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
```

Этот код ведет себя так, как заявлено, но возвращаемый байт указывает на массив, содержащий весь файл. Поскольку срез ссылается на исходный массив, до тех пор, пока срез находится рядом, сборщик мусора не может освободить массив; Несколько полезных байтов файла хранят все содержимое в памяти.

Чтобы исправить эту проблему, можно скопировать интересующие данные в новый срез перед его возвратом:
```
func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
```

Более краткая версия этой функции может быть создана с помощью append. Это оставлено в качестве упражнения для читателя.
