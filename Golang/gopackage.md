# Работа с ПАКЕТАМИ в Go

## Разделяющая область видимости на один пакет:

Pack > main.go + calculator.go

// main.go

```go
package main // Говорю что это пакет main в нем определена функция main()
import (
    "fmt"
    "Pack/rectangle" // Прописываем путь до пакета rectangle
)

// 0. Разделяющая облась видимости уровня одного пакета
// 1. В этом примере 2 модуля это (main и calculator) помещены в одну директорию Pack
// 2. Говорят что модули main и calculator находятся в одном пакете (в одной директории)

// 3. Разделяющая область видимости
// Все, что находится внутри данного пакета - доступно из любого модуля без импортирования.

func main() {
    // Данные функции видны кампилятору засчет того, что они реализованны
    // внутри модуля calculator КОТОРЫЙ ВХОДИТ В СОСТАВ ПАКЕТА MAIN!
  resAdd := Add(10, 20) // в этой ситуации лишние импортирования не нужны
  resSub := Sub(30, 40)
  resMult := Mult(50, 4)
  resDiv := Div(40, 4)

  fmt.Println(resAdd, resSub, resMult, resDiv)
    // 4. Для того, чтобы запустить все файлы в пакете надо выполнить:
    //* go run main.go calculator.go
    //* go build main.go calculator.go
    //* go install main.go calculator.go

    // 5. Вы обратили внимание, что функции которые затаскиваются в main -
    // начинаются с большой буквы
    // В Go принято - если имя сущности (переменная, функция, поля в структуре, структура. метод, интерфейс и т.д.)
    // начинается с большой буквы - данную сущьность можно экспортировать (она передаваема в другие модули и пакеты)
    // если же имя сущности начинается с маленькой буквы - данная сущность - не экспортируемая(нельзя передавать за пределы данного ПАКЕТА!)

    // 6. Создадим теперь дополнительный пакет с прямоугольником.
    // mkdir rectangle && cd rectangle && touch rectangle.go

    // 7. Проставим альтернативные пути
    // Альтернативный путь определяет точку входа ВО ВСЕ ПРИЛОЖЕНИЕ!
    // Для того чтобы его создать необходимо инициализировать файл GO.MOD
    // Данный файл будет отправной точкой для импортирования ВСЕХ ПАКЕТОВ ВНУТРИ ПРОЕКТА!
    // go mod init <ProjectDirName>

    // Реализуем внутри rectangle, метод и коструктор
    // 8. Попробуем импортировать все из пакета rectangle
    r := rectangle.New(10, 20, "green")
    fmt.Println("Perimeter:", r.Perimeter())

    // 9. Экспорьтруемость как инкапсуляция
    newR := rectangle.Rectangle{
        A: 10,
        B: 7,
        //color: 12,
    }
    fmt.Println(newR)

    // 10. Если уже создан файл go.mod
    // То сборка облегчается
    // go build (компилятор заглядывает в go.mod файл. Видит отправную точку)
    // go install

    // 11. ВСЕГДА ИСПОЛЬЗУЙТЕ GO.MOD ПРИ ИНИЦИАЛИЗАЦИИ ВАШЕГО ПРОЕКТА!
}
```

// calculator.go

```go
package main // он также находится в main, НО ФУНКЦИЯ MAIN() одна на весь пакет

// Реализуем 4 функции в модуле calculator

func Add(a, b int) int {
    return a + b
}

func Sub(a, b int) int {
    return a - b
}

func Mult(a, b int) int {
    return a * b
}

func Div(a, b int) int {
    return a / b
}
```

## СОЗДАЕМ НОВУЮ ДИРЕКТОРИЮ: rectangle/ rectangle.go

// rectangle.go

```go
package rectangle // Т.к. пакет main на весь проект один, тут мы создаем новый сторонний пакет

type Rectangle struct {
    A, B int // начинается с большой буквы
    color string // начинается с маленькой буквы. Данное поле больше не экспартируемо
}

// CONSTRUCTOR
func New(newA int, newB int, newColor string) *Rectangle {
    return &Rectangle{newA, newB, newColor}
}

// METHOD
func (r *Rectangle) Perimeter() int {
    return 2 * (r.A + r.B)
}
```

## Часть 2

```bash
mkdir Pack2 && cd Pack2 && go mod init Pack2
```

Pack2 > main.go

// main.go

```go
package main

import (
    "Pack2/rectangle"
    "fmt"
)

// 1. Функция init() - данная функция отрабатывает единожды при первом импортировании пакета
// 2. Данных функций в пакете может быть несколько штук! (не в одном модуле, т.к. в одном модуле нельзя создать
// более одной функции с какимто определенным именем)

// 3. init() вызывается в момент инициализации пакета:
//* Данный процесс выглядит следующим образом
//** сначало компилятор смотрит на содержимое пакета
//** затем компилятор смотрит на пути импорта (если что-то импортируется компилятор уходит туда)
//** затем компилятор инициализирует переменные уровня пакета
//** затем компилятор запускает функцию init() для данного пакета
//** повторяет данную процедуру для всех пакетов проекта
//** после чего вызывается функция main()

// 4. Что произойдет если запустить go run main.go
//* Сначало смотря в main.go на предмет синтаксических ошибок, но ничего не инициализируется
//* Затем импорты : сначало импортируем Pack2/rectangle
//** Компилятор идет в rectangle
//** Смотрим в пакет на предмет синтаксических ошибок
//** Затем import fmt
//** Затем инициализируем переменные уровня пакета
//** Затем запускаем функцию init() пакета rectangle
//** Затем подгружаем (определяем) все имена пакета rectangle
//** Функции main() тут нет возвращаемся назад
//* Пытаемся импортировать fmt (т.к. он уже был импортирован одним из пакетов - повторный импорт не требуется)
//* Инициализируем переменные уровня пакета main
//* Запускаем функцию init() в main
//* Затем определяем имена (тут дополнительных имен нет, тут ничего не делаем)
//* Затем запускаем функцию main()

//5. Все импорты (вне зависимости, стандартные или пользовательские) сортируются по алфавиту
func init() {
    fmt.Println("Init function from main package!")
    fmt.Println("Name:", name, "Age:", age)
}

var (
    name string = "Bob"
    age int = 99
)

func main() {
    r := rectangle.New(10, 10)
    fmt.Println(r)
}
```

**Pack2 > mkdir rectangle/
rectangle > rectangle.go**

// rectangle.go

```go
package rectangle

import "fmt"

func init() {
    fmt.Println("Init function from rectangle package!")
    fmt.Println("Name:", name, "Age", age)
}

// 1. Инициализируем переменные уровня пакет
var (
    name string = "John"
    age int = 33
)

// STRUCT
type Rectangle struct {
    A, B int
}

// CONSTRUCTOR
func New(newA, newB int) *Rectangle {
    return &Rectangle{newA, newB}
}
```
